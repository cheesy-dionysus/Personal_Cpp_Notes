-------------------Pattern matching in text files-------------------

egrep (extended global regular expression print)

Usecase: egrep pattern file - prints every line in the file that is matching the pattern

eg: print every line in the file index.html that contains cs246 
--> egrep cs246 index.html // pattern = cs246

how many lines in index.html contain cs 246?
--> egrep "cs246|cs 246" index.html | wc -l 
// find the pattern, then pipe output of egrep to wc 
// (-l gives the number of lines) to get number of occurences

OR 

--> egrep '(cs|CS) 246' index.html | wc -l 
// allows to search for both “cs246” and “cs246”

available patterns called regular expressions, different from globbing patterns

"[cC][sS] 246" [] means to look for any one char between [ and ] 
               [^...] means to look for any one character except ... 

Now try adding an optional space: 
"[cC][sS] ?246" 
	? = 0 or 1 or preceding expressions // so we are looking for:
		“cs(0 or 1 space characters)246”
	
Now what if you want to leave multiple spaces?
	* = 0 or more of preceding  spaces. notice that its different from globbing
“cs( )*246” // we are looking for “cs(0 or more space character)246”

Similar example: 
"(cs)*246" // we are looking for “(0 or more occurences of “cs”)246”
Possible results -> 246, cs246, cscs246, 

Next regular expression is a . (dot) matches any single character
	.* then means anything at all 
// we are saying 0 or more occurances of any character, which imples, find everything 

"cs.*246"
Possible results -> lines containing cs(anything in between)246

Always remember that egrep gives you lines that contain the pattern, not number of occurences

More regular expressions

^,$ - beginning and end of a line. //begin matching exactly with the characters after ^(chars)
// match line that ends with character before (chars)$

"^cs246" // lines that start with cs246

"^cs246$" // lines that are exactly like cs246

last regular expression is:
.+ // 1 or more ocurences of preceding pattern

.+ gives you anything non-empty // looking for any one character occuring atleast 	once. Means we are looking for non-empty

eg: We are looking for lines of even length

(..)* this gives you even lines, but 0 is even too. so you have to fix it with "^(..)*$" which means that it will have atleast 2 in length.
	// the two dots in brackets mean any two characters, so its either 2,4,6..

List files in current directory with names containing exatly one a 

ls | egrep "^[^a]*a[^a]*$" // start with 0 or more occurences of not a
	// then look for 0 or more occurences of a with no a after it

Look for all words in the global dictionary that start with e and have 5 characters 

egrep "^e....$" /usr/share/dict/words // starts with e and .... means any 4 other 	characters after e

-------------------------------Permissions-------------------------------

	new flag for “ls” command. ls -l gives the long form listing

eg:
-rw-r----- 1 j2smith j2smith 25 Sep 9 15:37 abc.txt

Char 1:
type - what kind of file is it.
	// - an ordinary file. 
	// d is a directory 

Next 9 characters are permissions, 3 groups of 3 bits 
	1st 3 are user bit (file owner)
	2nd 3 are group bits 
	3rd 3 are the other bits (for all other people)
they tell you what each class of user can do to a file or directory

Next we have # of links:
	owner - user that owns the file
	groups - grops is how linux allows file sharing. a user can belong to 1+ 				groups 
             - a single file can be associated with one group

Then we have:
	size - file size in bytes
	last modified - last modified timestamp
	name - filename

Q: What would happen if you are inside a directory where you have r bit disabled? 
A: its like being in a dark room. if you know what is in the directory, you can get 	to it, if you dont, you can only try guessing

A: On the other hand, if the directory bit is not set it is like a brick wall.
Means that you have no acces to the directory nor to any file or subdirectory.

Now consider changing permissions 

command: chmod [mode] [file] 
// mode is u for user
	     g for group
	     o for other
	     a for all,
		 
// + to add permission
   - to remove permission
   = to set permission
 
eg: if you want to give everyone permission to read file
--> chmod o+r [file]

if you want to make everyones permission read and execute 
--> chmod a=rx [file] // need equal because someone might already have write permission and you want to take that away from them

what if you want to give a user full control? 
--> chmod u=rwx [file] // or u+rwx file
// file/directory owner can always change the permissions so can root


-----------------------------Shell scripts-------------------------------------
	// files containing sequences of shell commands executed as programs

eg: we want to print date, current user, current dir
#!/bin/bash // this is called “shebang line” needed to tell bash where to look for 		// our code
date
whoami
pwd

to execute, you have to type ./myscript in command line 
// here we are saying that bash should look in ./  (current) directory for script

since we are talking about programming, you can set variables here too:

eg: x=1 
// in variable declaration, no spaces are allowed. Because then, the shell will think that you are running a command called 'x', with args “=” and “1”)

Now getting value of a variable:
eg:
echo x
// will not work, because it will simply return 'x', you have to use something to tell echo to fetch the x value

Instead, we should use:
eg:
echo $x

Notes:
* Use $ when fetching the value of a variable, No dollar sign when setting a variable tho.		 
* Good practice: ${x} might change things occasionaly when you dont know where the variable name ends. For example ${file}.in is different from $file.in
* Finally, all shell varibales are Strings

eg: 
dir=~/cs246
echo ${dir}

Output:
/u3/username/cs246
	
There are also come global variables that are always available to you:
eg:
${PATH} // a list of dirs separated by colons. 

Reason why shell could't find your script earlier (when you run without “./”)is because it has a set list of directories to look for programs that you are trying to run.
When you type a command, shell searches these directories in order to find a program with that name

There is a difference here too:
	* echo "$PATH" --> expands // “” returns value of $PATH
	* echo '$PATH' --> doesn't expand // '' returns var name PATH

Special variables for Scripts:
	$1, $2, $3 .... $n 
// these values represent command line argumens that you pass to your script
	
eg: Check wether a word is in the dictionary (./isitaword hello)
	#/!bin/bash
	egrep "^$1$" /usr/share/dict/words
	
eg: a good password should not be found in a dictionary. check whether a word is a good password
	#!/bin/bash
	egrep "^$1$" /usr/share/dict/words > /dev/null 
// now we don't want egrep to print anything, so we redirect output to /dev/null. It's like a black hole where you can redirect all the output to dismiss it

// Note: every program returns a status code, when finished. In case of egrep, the status codes are 0 if found 1+ matches and 1 if not found. (And thats a general convention: 0 = success, !0 = failure)
							   
// Usually, 1 is an expected failure, and larger numbers represent more serious failures

“$?” is the status of the most resently executed command

Now, if statements:

if [ $? -eq 0 ]; then 

// Be very careful with spacing. What it does is runs a command and checks for 	success.
// “[“ is the name of a program and other things are the arguments. 
// “;” is needed to separate commands, otherwise you'd have to put “then” on the 	next line

	echo “Bad Password”
	else
	echo “Maybe a good password”
fi

eg: now we want to be more careful about the input and verify arguments. Print error messge if something is wrong

#!/bin/bash
usage () {
	echo "Usage: $0 password" >&2 
	// “$0” is the command itself “>&2” means redirection of output to the stderr
	}
	if [ $# -ne 1 ]; then // $# - number of arguments
	    usage // calling function usage()
	    exit 1 // exit with expected error
	fi // closing if statement
	.... as before ....

In general, the if statemnt looks like this:
	if [ cond ]; then
		-
		-
		-
	elif [ cond ]; then // many more conditions are available on the handout
		-
		-
		-
	else 
		-
		-
		-
	fi 

------------------------------Loops------------------------
	
	WHILE LOOP:
eg: print numbers from 1 to $1
    #!/bin/bash
    x=1
    while [ $x -le $1 ]; do
    echo $x
    x=$((x+1)) // this wont work x=$x+1, because $x is a string and you will get "1+1"
    done

Though, most of the time we are going to be looping over a list of files, so we need a different kind of loop
	
	FOR LOOP:
eg: you want to remame all .cpp files in pwd to .cc
    #!/bin/bash
    for name in *.cpp; do // *.cpp is a glob that finds all matching files
    mv ${name} ${name%cpp}cc // "${name%cpp}" is the value of name without the trailing cpp
    done
		
eg: how many times does the word $1 appear in the file $2
    #!/bin/bash
    x=0
    for word in $(cat $2); do
    if [ "$word" = "$1" ]; then // because we are not comparing strings, we are using =, for numbers use -eq
	x=$((x+1))
	fi
    done
	echo ${x}
	
eg: Payday is the last friday of the month. When is this month's payday?
    2 tasks: compute date, report answer
	#!/bin/bash
	answer () {
	  if [ $1 -eq 31 ]; then // inside a function $1, $2 ... $n are the arguments of a function
	  echo "This month: the 31st"
	  else
	  echo "This month: the ${1}th"
	  fi
    }
	answer $(cal | egrep "[0-9]" | awk '{print $6}' | tail -1)  
	    
Generalize to any month, but if you dont give a specific month to the program, it will work the old way
	#!/bin/bash
	answer () { 
	  if [ $2 ]; then 
      	preamble = $2
      else
      	preamble = "This month"
      fi

	  if [ $1 -eq 31 ];
      	echo "${preamble} the 31st"
      else
      	echo "${preamble}: the ${1}th"
      fi
    }
	answer $(cal $1 $2 | awk '{print $6}' | egrep "[0-9]" | tail -1) $1 // $1 is the month, if there is no month and a year, then $1 and $2 are blank, nad we get the old behaviour

---------------------------Testing--------------------------
	essential part of program development
	
Machine testing
	- run program on selected input check against spec
	- can't always check everything, so you have to check your test cases carefully

Black box - tester has no knowledge or access to the internal workings of a program
Grey box - tester has limited knowledge of the internal details of the program
White box - tester uses program's source code as basis for designing tests
	
So we always start with black box, and then add white box tests 

Various classes of input
	- numeric inputs
	- positive vs negative
Boundaries of valid ranges (very important)
	- edge cases
	- multiple edge cases silmuntaneous (corner cases) 
Intuition/Experience will allow for better tests, because you will have understanding of where code usually breaks
Extreme cases (maximum difficult variables)
White box tests - execute all logical paths through the program (Coverage)
	- make sure all your functions get called atleast once
	- make sureevery single line of your code has been used
Performance testing - is the program efficient enough?
Regression testing - sometimes you fix one thing, but then break something else. Have to look out for those
	- thats why we use test suites, testing scripts, this way we can keep adding tests until we cover everything


----------------------C++--------------------------
	We will learn c++14

	Start with what we know, so in C
	
Hello World in C:
	
#include <stdio.h>
int main() {
  printf("Hello World\n");
}

Hello World in C++
	
#include <iostream> // stdio.h printf is still available here, but preffered to use header <iostream>
using namespace std; // lets you say cout/endl instead of std::cout/std::endl			   	

int main() { // main must return int in C++
  cout <<"Hello World"<<endl;
  return 0; // this is a very good practice to return something at the end. Technically we do say that main() returns int.
}

How to compile C++ programs?
-> g++-5 -std=c++14 program/cc -o program // "-o program" name of created executable, by default: a.out

Since we did aliases to out profile in a0, we can write compilation command in a much shorter form:
-> g++14 program.cc -o program
and to run your program, type: 
-> ./program

printf and other c code is banned in this course, always use c++ functions, methods, expressions, etc..

-----------C++ I/O streams-----------------

C++ gives you 3 i/o streams
	- cin for reading from stdin
	- cout, cerr for printing to stdout and stderr

I/O operators: 
	<< means "put to" for output
	>> means "get from" for input

So you can do code like this: 
	cerr << x; - information is flowing from x to cerr
	cin >> x; - information is flowing from cin to x 

Arrows show where the information is flowing and its direction

eg: add two numbers

#include <iostream>
using namespace std;

int main() {
  int x, y;
  cin >> x >> y;
  cout << x + y << endl;
  return 0;
}

cin operator ignores whitespace 
 - if input doesn't contain numbers, cin fails and var is undefined
 - if input is exhausted before we give 2 ints, we press ^d (EOF) then the statement fails and var is again undefined
 - if read fails, there is an expression cin.fail() which will always be true when read fails
 - if you get EOF, then cin.eof() and cin.fail() will both be true // However, these won't turn on, until you try to read file and fail

eg: read all ints from stdin, echo them one per line to stdout, stop on any failure

*********v1.0 of example***************
int main() {
  int i;
  while (true) {
  cin >> i;

  if (cin.fail()) break;

  cout << i << endl;
  }
}

there is an "implicit conversion" (remember this word) from cin or cout to bool, which means you can use cin as a condition
 - so cin is true if successful and false if failed

********v2.0 of example*********** 
int main() { 
  int i;
  while (true) { 
    cin >> i;

    if (!cin) break;

    cout << i << endl;
  }
}

Now a little bit more details about >> << operators
 - >> this is C's right bitshift operator. a >> b shifts a's bits to the right y b spots

eg: 
	21 >> 3 
	we know that 21 = 10101 
	So 21 >> 3 = 01 >> 11 = 10
this means the same in C++, cin moves a bits to b, hence "get from"

operator >> : 
 - has inputs cin on the left (istream) and data on the right (variety of inputs)
 - output? - returns another cin (istream)
 - this is why you can write cin >> x >> y >> z; 

*********v3.0 of example **************
int main() { 
  int i;
  while (true) {
  if (!(cin >> i)) break;
  cout << i << endl;
  }
}
  

********v4.0 of example ***********
int main() { 
  int i;
  while (cin >> i) { 
    cout << i << endl;
  }
}

eg: read ints and echo to stdout until eof, skip all non-int input

int main() {
  int i;
  while (true) {
	if (!(cin >> i)) {
	  if (cin.eof()) break;
	  cin.clear(); // clears the fail bit. But the wrong character is still in the stdin.
	  cin.ignore(); // means to skip the next character
	}
	else cout << i << endl;
  }
}

------------------------Reading Strings------------------------

c++ has a type std::string, which you get by #include <string>

int main() {
  string s;
  cin >> s; // skip leading whitespaces and stop at the next whitespace (reads one word)
  cout << s << endl
}

if you do actually want to read the whitespaces, use: getline(cin, s)
 - reads form current position to new line into s

Examples:
	cout << 95 << endl; // will print 95 to the screen now if you want to show the value in hexadecimal.
	In C you have to use %x with printf, but there is no printf in c++

So we use this instead:
	cout << hex << 95 << endl; // prints 5f, which is 95 in hexadecimal
	hex - is an io manipulator. It works in a way, that from now on, all subsequent ints are printed in hex
	
if you want to print only one in hex, use "dec" to go back to decimal. (There are many manipulators that are available to us. You can find those in the printed notes)
	many of the manipulators will require to use #include <iomanip>

Stream abstraction applies to other sources of data. For example, files
 - You may want to read from a file, rather than stdin
 - std::ifstream - read from a file
 - std::ofstream - write to a file
	
-----------------------File access in C----------------------------

int main () {
 char s [256];
 FILE *file = fopen ("myfile.txt", "r");
	
 while (true) {
    fscanf(file, "%255s", s);
	if (feof(file)) break;
	printf ("%s\n", s)
  }
  fclose(file); // awlays have to close the file
}


----------------------Now file access in C++------------------------

#include <iostream>
#include <fstream>
#include <string>
using namespace std;

int main() {
  ifstream file {"myfile.txt"}; // shit in the curly brackets is initialization syntax. Declaring the ifstream, opens the file.
  // We will see this notation later again
  string s; // string is now a type and they manage their own size, not like C

  while (file >> s) { // this will only read a word at a time, use getline(file, s) to read a line
	count << s << endl;
  }
// no fclose(), the file is closed automatically, as soon as ifstream goes out of scope
}

Anything you can do with cin and cout, you can also do with an ifstream and ofstream

Example:
 - strings: attach stream to a string variable and read from/write to it
 - the include for stream string is #include <sstream>
 - types are std::ostringstream, std:istringstream 

Imagine you have two ints lo=xxxx, hi=yyyy and you want to use them to print a string:
	ostringstream ss; // create a string stream variable
	ss << Enter a # between " << lo << "and" << hi; // you first fill in the stream
	string s = ss.str(); // then you turn the stream into a string

eg: Convert string into #
int main() {
  int n;

  while (true) {
	cout << "Enter a # " << endl
	string s;
	cin >> s;
	
	istringstram ss {s}; // shit in {} is initialization
	// you first read in a string, then turn it into a stream

	if (ss >> n) break; // check if you got an integer out of the stream
	
	cout << "I said, "; // if no ints, keep reading
  }
  cout << "You entered " << n << endl;	
}

EXAMPLE revisited: read in #s, skip non-ints

int main() {
  string s;
  int n;

  while (cin >> s) { // the only way reading a string can fail, is if you have EOF
	istringstram ss {s}; // you put the input into a string stream
	if (ss >> n) cout << n << endl; // then you try to get out an int from the stream
  }	
}

Behaviour is slightly differnt tho, try printing "a1s2d3f4" with both functions

--------------------------Strings------------------------

in C strings are char* or char[] terminated by \0
 - you must explicitly manage memory
 - you must allocate more, as strings get larger
 - very easy to overwrite that trailing "\0" and corrupt your memory

in C++ strings
 - grow as needed, no need to manage memory
 - safer to manipulate, because they don't depend on the "\0"

eg (Very important to understand):
	
string s = "hello"; // "hello" is still a C style string with chars |h|e|l|l|o| 
// s is a C++ string created from C string upon initialization
// this is needed for the backwards compatibility with C
// this works because of implicit type conversion

C++ String operations:	
 - Equality: s1 == s2, s1 != s2
 - Comparison: s1 <= s2 (lexicographic)
 - Get invidual characters: s[0], s[1] ... s[n]
 - Concat: s3=s1+s2; s3+=s4;
 - Length: s.length()

* more details are in the printed notes


		Default f'n params:

void printWordInFile (string name="suite.txt") { // passing a default parameter 
  // name can be passed when we call function, but it is not passed, a default value is used
  ifstream file {name};
  string s;
  while (file >> s) cout << s << endl;
}

Now you can call: 
printWordsInFile("test.txt")
Or say printWordsInFile() // and it will use default value
IMPORTANT: optional parameters must always come last 
	 imagine you have a f(int k=5, int n) // if you call f(5) the compiler won't know wif n is 5 or if k is 5


		Overloading:
c: 
int negInt(int n) {return -n;}
bool negBool(bool b) {return !b;} 

c++: Functions with different parameter names, can share the same name
int neg(int n) {return -n;}
bool neg(bool b) {return !b;}

The act of doing this, is called overloading. 
	Now when you call a function by its name, how does the compiler know which one, you meant?
	 - compiler, uses the number and type of the arguments to decide which name is being called. So overload must differ in # of args or types of args
	 - may not simply have different return types

------------------Structs----------------------
	
struct Node {
  int data;
  Node *next; // in c++ you dont have to mention that Node is a struct
};

struct Node {
  int data;
  Node next; // what is wrong with this? -> We have a node inside of a node. You would not be able to tell the size of this stucture
};

-------------------------Constants------------------------
Constants: const int maxGrade = 100; //must be initialized, you should be using it as much as you can
	
Node n1 = {5, nullptr}; // sytax for null pointer. Null is not a built in variable in c or c++
// null usually is a number = 0, But that could be a problem because you want to use a null for a pointer and it will give you a number, not a pointer
// thats why c++ came up with nullptr so that you dont have to use null for pointers
	
const Node n2 = n1; // this is an immutable copy of n1, means that you can't change n2's fields

----------------------Parameter Passing------------------

Recall the following from 136: 
void inc (int n) {++n;}
...
int x = 5;
inc(x);
cout << x << endl; // still prints 5
// example of call by value, where inc() gets a copy of x, increments the copy and the original is unchanged.
	
// if you would like to inc to be able to modify the x, you want to pass the pointer to the value, rather than a copy
void inc (int *n) {(*n)++;}
...
int x = 5;
inc(&x); // using x's address, rather than the value
cout << x << endl; // prints 6 	 

Q: Why do we say cin >> x and not cin >> &x?
A: C++ has another pointer like type, they are called references

-------------------------References-------------------------- 
					(VERY IMPORTANT)

	int y = 10;
	int &z = y; // im saying, z is an lvalue reference to y
				// like a const pointer, similar to a declaration like:
				// int *const z = &y (not exactly the same tho)

	References are like constant pointers with automatic dereferencing
	
	z[]---->y[10] // z is pointing to the memory location of y and can't be changed

	z = 10; (not *z=10;) // and we get that y == 10

	int *p = &z; // trying to take the address of z, but when you do it, it gives you the address of y
				 // so in all cases z behaves exactly like y, they really should be indistinguishable

	we can say z is an alias ("another name") for y
	
	Rules for referencing: "Things you cant do with lvalue references" 
	1. Can not leave them uninitialized //eg: int &x;
	2. Must initialize to something that has an address // "something that has an address" is called lvalue - the thing on the left of the assignement value
		// eg: int &x = 3; bad
		// eg: int &x = y + z; bad 
		// eg: &x = y; good
	3. Cannot create a pointer to a reference: int &*x; bad // always start with the variable and work your way up
		But, perfectly legal to create reference to a pointer: int *&x= ____; good
	4. Cannot create a reference to a reference:
		int &&x=___; // this means something different (covered later)
	5. Cannot create arrays of references: 
		int &r[3]= {n,n,n}; bad

	Rules: "Things you can do"
	1. Pass references as function parameters. 
		void inc (int &n) {++n;} // &n is a constant pointer to the argument. 
								 // Notice: no pointer dereference, and printing passed value later will give you incremented value

	Q: So why does cin >> x works? 
	A: Because the operator that you are using takes x by reference

	Now we can discuss the exact signature of an input operator:
	istream &operator>> (istream &in, int &data) // why use references? because rather than using call by value, where you take a copy. It is not allowed to copy streams, 
												  // also means you can't pass it by value, can only pass by reference	
	Pass by value. eg: int f (int n) {...} // copies the argument
	-- If the file is very large, then the copy can be expensive 
	
	eg: struct ReallyBig {....}; // if you create a pass by value function on that.
		int f (ReallyBig rb) {...}; // to avoid copying, you can pass it by reference
		int g (ReallyBig &rg) {....}; // since i didn't do any copying, this thing is fast
	"Downside: i can no longer guarantee that rb won't change".
	
	So the question is can you have the best of both worlds, where its fast and won't change? Yes!

	int h (const ReallyBig &rb) {...}; // this way its still fast (no copying) and the parameter cannot change. 
	"Only downside left is if you actually wanted to change rb inside the function, but not outside"
	So here is the advice: 
	Prefer to pass-by-const-ref over pass-by-value for anything larger than a pointer. Unless the function needs to make a copy anyway - then maybe pass by value. 
	
	**** 1 More example ****

	int f(int &n) {....};
	int g(const int &n) {...}; 
	
	f(5); // this won't compile
	// because 5 doesn't have an address. Can't initialize an lvalue reference to a literal value.
	// if n changes, can't change the literal 5 because reference is not pointing to a memory
	
	g(5); // perfectly legal
	// because its a constant reference. Since n can never be changed, the compiler allows this.
	// how? - compiler creates a temp location to hold the 5, so ref n has something to point to. 

--------------Dynamic Memory Allocation----------------
	In C, we used to do this: 
	int *p = malloc(_______*sizeof (int));
	....
	free(p);
	"DONT USE THIS IN 246"
	
	Instead, use new/delete, which is better because its:
	-- type aware
	-- less error prone
	
	EXAMPLE TIME!!
	struct Node {
		int data;
		Node *next;
	};
	When this runs, lets look at the stack and the heap:

	Stack:
	------
	np // points to values that are on the heap

	Heap:
	------
	data
	next

	Create a new value on the Heap
	Node *np = new Node;
	....
	delete np;
	
	All local variables are stored on the stack, varaibles are deallocated once they go out of scope. (stack is popped)
	Allocated memory is stored on the heap, it remains there until i say "fuck this shit, im done" (delete is called)
	If you don't delete all allocated memory, you will have a memory leak. Program will eventually fail - incorrect behaviour

	Note: before we asked for space to store only one node
	But we sometimes want to store more things, so we do this:	
		Node *np = new Node[10]; // allocates space for 10 nodes. 
		....
		delete [] (np);

--------------------Return-by-value----------------------
	
	eg: 
	Node getMeANode() {
		Node n;
		return n;
	} // maybe the best option because you might want to take a risk of extra memory use but not have to worry about clearing memory

 	Creating a node and giving it back to the user, requires making a copy. Could be expensive!
	
	Q: How to avoid that copy? 
	A: Return by pointer(ref) instead. 

	Node *getMeANode() {
		Node n;
		return &n;
	} // one of the worst things you can do

	IT RETURNS A POINTER OR A REFERENCE TO A STACK-ALLOCATED DATA THAT IS DEAD ON RETURN.
	// out of scope!!!
	// problem that you will not actually crash a program right away and compiler might not tell you what the problem is

	If you want to return something fast, make sure the thing you are returning is not from the stack
	Node *getMeANode() {
		return new Node; // new allocates space on the HEAP
	} // this works, but you gotta remember that there is something on the heap and you have to delete it at some point	
	
----------------------Operator overloading--------------------

	(this is amazing, changed my life #revolutionary)

	Operator overloading allows us to give meanings to C++ operators for our own types
	eg:
	struct Vec {
		int x, y;
	};

	Vec operator+ (const Vec &v1, const Vec &v2){
		Vec v={v1.x+v2.x, v1.y+v2.y};
		return v;
	}

	Vec operator* (const int k, const Vec &v) {
		return {k*v.x, k*v.y}; // ok because the computer knows that its a Vec based on the return type
	}
	
	Vec operator* (const Vec &v, const int k) {
		return k*v;
	}; 

---------------Overloading << and >> (I/O operators)-------------------

	eg:
	struct Grade {
		int theGrade;
	};


	ostream &operator<< (ostream &out, const Grade &g) { // you have to use references because ostream can not be copied
		out << g.theGrade << '%' // to print a percent sign every time after the grade
		return out; // or "return out << g.theGrade << '%'"
		// key is that we have to return ostream, just like cout does
		// this way we can use cascading effect: cout << x << y << z << endl;
	};

	istream &operator>> (istream &in, Grade &g) { // no const for Grade because you want to change it
		in >> g.theGrade;
		if (g.theGrade < 0) {
			g.thegrade = 0;		
		} 
		if (g.theGrade > 100) { 
			g.theGrade = 100;
		}
		return in; // have to return istream because of the cascading effect
	}
	
	int main () {
		Grade g;
		while (cin >> g) cout << g << endl;
	}

--------------------------The Preprocessor------------------------

	Transforms the program before the compiler sees it. 
	// you know you are dealing with a preprocessor because you will see a line like this: 
	// #_______ - preprocessor directive 
	We already know the #include
		- if you are including old C headers, there is a new naming convention:
		eg: instead of #include <stdio.h> use #include <cstdio>

	#define VAR VALUE // sets a preprocessor variable.
	// acts like search and replace. If preprocessor ever sees a VAR anywhere, it will replace it with VALUE

	#define MAX 10 
	int x[MAX]; // transformed int x[10] a way to create constant variables
	This is very outdated tho, we use const definition instead
	Then why are we covering it? --> It can be used for other things 
	
	#define FLAG // sets the variable FLAG and its value is the empty string
	So once you compile the code, all isntances of FLAG will be gone.

	This is also useful for conditional compilation. Sometimes you want your program to look different in different situations. 
	In order to accomodate for different OSs, you have to vary code a little bit.

	eg:
	#define IOS 1
	#define BBOS 2
	#define OS IOS (or BBOS)
	#if OS == IOS
		short int publickey; // if true, compiler sees this
	#elif OS == BBOS
		long long int publickey; // if false, this code is suppressed and compiler doesn't see it 
	#endif 
	Remember that preprocessor runs before the compiler sees it. 
	
	Special Case:
	#if 0 // this is never true, all inner text is removed before it gets to the compiler
	#endif 
	Good as a heavy duty commenting out

	Can also define symbols via compiler arguments
	eg: 
	int main() {
		cout << X << endl; // won't compile, because x is undefined
	}
	
	But we can define x on the g++ command line
	--> g++ -DX=15 define.cc -o define // this use capitals for all defined variables
	
	#ifdef NAME // true if NAME has been defined
	#ifndef NAME // true if NAME has not been defined

	Useful for debugging
	eg:
	int main() {
		#ifdef DEBUG
			cout << "setting x=1" << endl;
		#endif
			int x=1;
			while (x < 10) {
				++x;
				#ifdef DEBUG
					cout << "x is now" << x << endl;
				#endif
			}
		cout << x << endl;
	}	

	if you compile it normally
	--> g++14 debug.cc -o debug
	if you want to debug 
	--> g++14 -DDEBUG debug.cc -o debug

	
-----------------Separate Compilation-------------------

	You want to split your program into composable modules, with an 
	- interface: contains things such as type definitions, prototypes of functions (your .h file)
	- implementation: the full definition of your functions (your .cc file)

	Recall: 
		when we speak of a declaration, all it does is it asserts existance, whereas definitions give full details and allocate space
		for those things that occupy space. 

	eg: if we take the Matrix functions from before and make them into proper files
	**************vec.h*************************
	____________________________________________
	struct Vec {
		int x, y;
	}

	Vec operator+ (const Vec &v1, const Vec &v2);


	*************main.cc************************
	____________________________________________
	#include "vec.h"
	
	int main() {
		Vec v = {1, 2};
		v = v + v;
		.....
	}


	*****************vec.cc*********************
	____________________________________________
	#include "vec.h"
	
	Vec operator+ (const Vec &v1, const Vec &v2) {
		....
		....
		....
	}

	Recall, an entity can be defined many times, but defined at most once.

-----------------Linker (Compiling separately)------------------------
	
	VERY IMPORTANT:
		ls the directory:
			vector.h vector.cc main.cc
		then you run:		
			g++14 vector.cc
		and get a shit error:	// if you get errors in /usr/bin/ld then you are fine, its a linking error
			look at the pre-last line: thats where the error is
		then you run:
			g++14 main.cc
		and get a shit error again // look at the end for error description again
		

	To compile separately, do:
	-> g++14 -c vector.cc
	-> g++14 -c main.cc
	// -c means compile only, do not link, do not build the executable
	So now we have a compiled, but unlinked code: 
		ls the directory:
		main.cc main.o vector.cc vector.o vector.h

	.o file is an object file all compiled, but not liked. 
	To do linking, use 
		g++14 vec.o main.o -o main
	now you can run ./main

	Notice, we didn't compile .h file. 

	NOTICE!!!!
	NEVER EVER, EVER COMPILE .H FILES EVER!!!!
	!!!!!!!!!code in the .h files is compiled automatically because it is included in other files

	Suppose you wanted to add a global variable 
		Global var: int globalNum;
	You should never include it in the .h file because every time the .h file is included compiler will make a copy of it
	You have to define it in .h, but not initialize it using extern global var;
	Initialize the variable in a .cc file global var = 14;

------------------------Including shit in your modules---------------------------

	imagine you have vec.h, vec.cc, linalg.h, linalg.cc, main.cc
		!!!!!!this won't compile!!!!!!!!! 
	main.cc, linalg.cc include linalg.h, vec.h
	linalg.h includes vec.h

	-> main.cc, linalg.cc get 2 copies of vec.h

	STRUCT VEC IS DEFINED TWICE 

	Need to prevent files from being included

	Solution: 
	Vec.h:
	#ifndef VEC_H
	#define VEC_H
	.
	. // file content
	.
	#endif

	First time vec.h is included symbol VEC_H is not defined, so file is included. After that VEC_H is defined, the contents are suppressed

	Rules: 
	- ALWAYS put include guards in .h files 
	- NEVER include .cc files // you will end up with 2 copies of definitions and functions because you will get one from .cc file and another when .cc is included somewhere else
	- NEVER put using namespace std in header files // if you do that, you are forcing your client not to use std namespace either, which is not fair
		- inside header files always say std::cin, std::string etc.

	Midterm coming up
	-> Better study, do not be behind on aynthing! gotta understand week 1 content

-----------------------------------------OOP Classes------------------------------
	- is different from structs because you can put functions inside of classes
	
	eg:
	struct Student {
		int assns, midterm, final;
		float grade () {
			return assns*0.4 + midterm*0.2 + final*0.4;
		}
	}

	Student s{60, 70, 80} // then you can create a struct 
	cout << s.grade() << endl // and use functions inside classes to return values

	Definitions: 
	- Class -> a struct type that can contain functions
			-> c++ does have a class keyword. We will cover it later

	- Object -> an instance of a class
			 -> So Student s{60,70,80}. Student is the class and s is the object
			 -> then function grade(), is called a member function or a method. First method that we have written in this course, before this, everything was functions.

	What do assns, midterm, final inside of grade() {.....} mean? What do they refer to, if in struct we didn't initialize anything?
		-> They are fields of the current object // upon which grade was invoked.

	eg: 
	Student billy{60, 70, 80}
	billiy.grade() // This is a method call and inside the grade(), billy's assns, mitderm, final are used.

	This is why methods and functions are different
		Formally: methods takes a hidden extra parameter called "this"
		- this is a pointer to the object on which the medhod was invoked
		eg: billy.grade() // this == &billy

		can write the following to be more formal:
		Struct Student {
			int assns, midterm, final;
			float grade() {
				return this->assns*0.4+this->midterm*0.2+this->final*0.4;
			}
		}

------------------Object Initialization----------------------

	Student billy{60, 70, 80} // ok, but a bit limited

	A better option would be writing a method that does the initialization for us
		- such a method is called a constructor

	Struct Student {
		int assns, midterm, final;
		float grade()  {........}
		
		Student(int assns, int midterm, int final) {
			this->assns=assns;
			this->midterm=midterm;
			this->final=final;
		}
	}

	Now that we have a constructor, we can do this:
		Student billy{60,70,80}; // this is much better

	DIFFERENCE: now we are calling our own constructor
	It works like this: if a constructor has been defined, the three variables are being passed to contructor,
						if no constructor has been defined, these initalize the individual fields of student.

	OR // a different syntax, but does the same thing
	Student billy = Student{60,70,80};

	before we were creating billy object on the stack. Now to create it on the HEAP:
	Student *pBilly = new Student{60,70,80};

	Advantages of constructors:
	- default parameters
	- overloading
	- sanity checks (validate values) 
		
	eg:
		Struct Student {
			....
			Student (int assns=0, int midterm=0, int final=0) {
				....			
			}
		}

		Now we can do Student Jane{60, 70} // where final is initialized as 0
		Student newKid; // all the marks are 0

	Note:
		- Every class comes with a default constructor (takes no arguments)
	eg: 
		vec v; // something we did a couple days ago. 
			   // this calls a default constructor. What it does is it runs through struct and default-constructs any fields that are objects
			   // in case of vec, it does nothing because there are no objects, all we had are the two ints, which are not considered as objects

	So if it does not do anything, how do you know that it's there?
	-> You can check by taking away the dafault constructor

	The built-in default constructor GOES AWAY if you provide your own costructor
	eg:
	Struct vec {
		int x, y;
		vec(int x, int y) {
			this->x=x;
			this->y=y;
		}
	};

	Now if we run vec v, it won't compile. It compiled before, but it won't anymore, because the default constructor has been overwritten by our own constructor
	// However, before, when we intialized structures the x and y were both uninitialized
	// Remember how we mentioned that default contructor only initializes objects?
	// What happens is that our default constructor, calls the other object's default contructor.. and so on

	What if a struct contains const or refs?
	Struct myStruct {
		const int myConst;
		int &myRef;
	} // this is interesting, because const and ref, must be initialized 
	 
	int z;
	Struct myStruct {
		const int myConst=5;
		int &myRef=z;
	} // we can do this, but its probably not what we want
	// because at the end we will end up with as many myCosnt as objects that we created. We will have way too many duplicates

	But does every instance of myStudent need the same value of myConst?
	eg:
	Struct myStudent {
		const int id; // doesn't change, but you don't need the same one for all students
		...
	}

	So if that is not what we need. How should we do it then?
	// by the time it gets to constructor body, it will be too late, because the fields should have been intialized before that

	What happens when an object is created? 
	1) Space is allocated
	2) Fields are constructed // we want to put our intializations here!!!
	3) Constructor body runs // its too late to intialize variables here because they happen in step 2

	We do that using MEMBER INITIALIZATION LIST (MIL)
	eg:
	Struct Student {
		const int id;
		int assns, midterm, final;
		Struct (int id, int midterm, int final):id{id}, assns{assns}, midterm{midterm}, final{final} { // before we start the construction body, right before the first "{"
			// there are rules tho. Shit before the curly brackets are fileds. Inside the brace brackets are the normal c++ scope rules and id, assns, midterm, final are just parameters
		}
	}

	Notes: 
	- Notice that you can intialize any field this way, not only const and ref
	- The fields are initialized in which they are declared in the class, not in order of MIL. // so that if one field uses a value of another, it still works
	- MIL is sometimes more efficient then setting fields in the body // because no matter what you do, step 2 is going to happen
		eg: you have a String name in your class. if you dont intialize String in your step 2, it will still happen because objects are always intialized in default constructor
			so you will do the work twice, to first initialize string as null and then to give it an actual value
	MORAL!!! embrace the MIL. You should be using it all the time in constructors
	
	What if a field is initialized inline, and in the MIL?

	Struct vec {
		int x=0, y=0;
		vec(int x): x{x} {
			....
		}
	} // MIL takes precedence over regular field initializations
	  // Basically overrides them with its own values 


--------------------Uniform Initialization--------------------------
	
Old ways to initialize:

	int x = 5;
	string s = "hello";
	
	OR

	int x(5);
	string s("hello");
	Student billy(60, 70, 80);

New Preferred method:

	int x{5};
	string s{"hello"};
	Student bily{60,70,80};

Now consider:

	Student billy{60,70,80};
	Student bobby = billy; // How does this intialization happen? 
		- the copy constructor 
		- for constructing one object as copy of another
		- so we get a copy constructor for free


Note: Be very careful with constructors that can take ONE parameter !!!!!!!!!!!
	eg:
	Struct Node {
		int data; 
		Node next;
		.....
		Node (int data): data{data}, next{nullptr} {
			......
		}
	};
	This is dangerous because single argument constructors create implicit conversions // Not good, means c++ is changing types behind your back
	Now we can do:
		Node n{4}; // which is totally cool
	but we can also do this:
		Node n = 4; // which means there is an implicit conversion from int to node
	We have already seen this in string hello = "hello"; // where it creates implicit conversion from char array to string
	Now consider this:
		int f (Node n) {.....};
		f(4); // this works for implicitly converted Node
	Danger is:
	- accidentally passing int to a function that is expecting a Node
	- compiler will not signal an error
	Good practice for these scenarios is to disable implicit conversion. To do that, make constructor explicit
	Struct Node {
		...
		explicit Node(int data): data{data}, next{nullptr} {
			.....
		}
	}
	Node n{4}; // is ok
	Node n = 4; // will signal an error
 

	Note: Every class comes with these constructors
 	- default constructor // default construts all fields that are objects
	- copy constructor // just copies all the fields
	- copy assignment operator 
	- destructor
	- move assignment operator

-----------------------------------Copy Operator----------------------------
	if you were to decide to build your own copy constructor, it would look like this:
		Struct Student {
			int assns, midterm, final;
			Student (....) {...} // old stuff
			Student (const Student &other): // you know its a copy constructor because it consumes a structure
			assns {other.assns}, midterm {other.midterm}, final {other.final} {.....}
			// this is exactly what the built in constructor does
		}
		Q: When do you need copy constructors that are different than default one?
		A: Obviously when we are working with linked lists, because that what they do, ruin your life

		Struct Node {
			int data; 
			Node *next;
			Node (int data, Node *next): data{data}, next{next} {.....}
			.....
		}

		Node *n = new Node{1, new Node{2, new Node{3, nullptr}}};

		Understanding memory alloc:
		|_Stack_|__Heap___________________|
		n -----> 1|* --> 2|* --> 3|nullptr

		Node m = *n;
		Node *p = new Node{*n}; // using copy constructor
	
		Understanding memory alloc:
		|_Stack_|__Heap___________________|
		m -> 1|* ----> 2|* --> 3|nullptr
		p -----> 1|* --> 2|* --> 3|nullptr
		// the problem here is that you are not copying, but you are simply pointing to already existing nodes 

		A simple copy of fields => only the first node is copied // known as a shallow copy
		// this is not what you want, most likely your intent was to copy the entire list	

		if you want a DEEP copy // copies the whole list
		Then you have to write your own copy constructor

		eg:
		Struct Node {
			int data; 
			Node *next;
			Node (int data, Node *next): data{data}, next{next} {.....}
			Node (const Node &other): data{other.data}, next{other.next?new Node {*other.next}:nullptr} { 
			// the trick is that when you call "new Node{*other.next}" recurses, so other values are copied too 
				....
			}
			.....
		}

		The copy constructor is called:
		1) when an object initializes another object
		2) when an object is passed by value
		3) when an object is returned by value (*not always - will discuss later)

		Note:
		- can't override copy contructor
		- should always give it values by reference

------------------------------Destructors------------------------------------

	When an object is destroyed:
		- if stack allocated -> goes out of scope
		- if heap allocated -> it is deleted a mathod called the destructor runs

	Every class has a default destructor // it calls destructors on all the object fields, just like the constructor, but the opposite

	Sequence of events that happens when an object is destroyed:
	1) destructor body runs
	2) field's destructors invoked in reverse declaration order
	3) space is deallocated

	Q: When do we need more out of destructor class?
	Node *np = new Node{1, newNode{2, newNode{3, nullptr}}};
	// if np goes out of scope, only the pointer memory is reclaimed (because its on the stack), the list is leaked

	If we say:
	delete np; // this calls *np's destructor, which doesn't do anything 
			   // 1|*-> 2|*-> 3|nullptr. When we run destructor, it kills only objects. 
	So what happens is we delete *np, first node, but the rest of the list is leaked

	Writing a destructor // "~" tilda is what denotes destructor
	Struct Node {
		......
		~Node(){delete next;} // the way that this works is we delete next and call next's destructor, which deletes the next next etc...
		// so this is recursion again
		// we forogot to check for the case of nullptr, but in c++ it is safe to delete nullptr, so we are good to go
	}
	Now: 
	delete np; // deletes the whole list

--------------------------------Copy Assignment--------------------------
	the hardest and trickiest one (will be on the midterm, because everyone fucks it up)

	Student billy{60, 70, 80};
	Student jane = billy; // copy constructor
	
	Now consider if we do this:
	Student mary; // default constructor
	mary = billy; // we are copying billy, but we are not constructing mary
	// "=" is an instance of copy-assignment operator. If you don't provide your own, then it will use the compiler's one by default
	// again, the default one might not be good for all the cases, so sometimes we have to write our own
	// Usually, we need to write our own when we work with pointers. We want to avoid SHALLOW copies
	
	Struct Node {
		.......
		Node &operator=(const Node &other) { // notice that the return type has to be a Node
		
		"""
			Aside: in c++ you can do this:
			a = b = c = 4;
			c = 4; -> b = c; -> a = b;
			that's why we need to return Node, so that cascade effect works
		"""	

			data = other.data;
			delete next; 
			next = other.next?new Node{*other.next}: nullptr; // note we are not building a new object, we are using an object that already exists
			return *this;
		} // So apparently this is all wrong and we just spent 10 minutes on this
	}
	Why dangerous?
	Node n{1, new Node{2, new Node{3, new Node}}};
	n = n; // so now we are deleting old data first, but then we try to access deleted data, 
	// which will probably mess up your whole life and you will have to drop out from CS program and go back home and cry a lot, A LOT, A LOOOT.. 
	This gives undefined behaviour
	NOTE: WHEN WRITING OPERATOR = ALWAYS BE AWARE OF SELF ASSIGNMENT

	So the right version:	
	Struct Node {
		.......
		Node &operator=(const Node &other) {
			if (this == &other) return *this; // now if we encounter self-assignment, we will simply return pointer to this

			data = other.data;
			delete next; 
			next = other.next?new Node{*other.next}:nullptr;
			return *this;
		} 
	}

	Now this is apparently an even better version:
	Struct Node {
		.......
		Node &operator= (const Node &other) {
			if (this == &other) return *this; // now if we encounter self-assignment, we will simply return pointer to this
			// now we happpen to know that new doesn't 100% work, that it might fail. And if new fails, this function will bail out because we wont be able to set a value for next
			// and next will keep pointing to old memory, which corrupts the list
			Node *tmp = next;
			next = other.next?new Node{*other.next}:nullptr; 
			data = other.data;
			delete tmp;
			return *this;
		}
	}	
	This is better because if new fails, next and data has not been cahnged yet, so the node is still in valid state
	Also, the actual check for self assignemnt is not necessary here, because we are making a copy of other no matter what, since im working of a copy, 
	it doesn't matter if we are copying form somewhere else or from myself.

	Now there is another version of operator Equal that does everything that the previous version, but is much simpler to write

	#include <utility>

	struct Node {
		...
		...
		...
		void swap (Node &other) {
			using std::swap;
			swap (data, other.data);
			swap (next, other.next);
		}

		Node &operator= (const Node &other) {
			Node tmp=other; //tmp = copy of other
			swap (tmp); // me = copy of other, tmp = my old fields 
			// now since tmp is stack allocated, it is destroyed when this is returned
			return *this;
		}
	}

-------------Rvalues and Rvalue operators-------------------

	recall: an lvalue is anything with an address
			an lvalue reference is like a constant pointer with automatic dereferencing and is aways initialized to lvalue

	Node n {1, new Node{2, nullptr}};
	Node m = n; // copy operator
	Node m2;
	m2 = n; // copy assignment operator

	Node plusOne (Node n) {
		for (Node *p = &n; p; p = p->next) {
			++p->data;
		}
		return n;
	}

	what we get from here is a copy of the original list with every value increased by one

	Now we want to do this:
	Node m3 = plusOne(n); // here we run the copy constructor

	But when we run this, we get 2 calls to the Basic Contructor and 4 calls to the Copy constructor
	- 2 calls to the Basic constructor because of the two nodes that we have
	- the question is why the copy contructor gets called twice (2 on way in, 2 on way out)
	- because there are 2 nodes in the list, it calls itself recursively, so for every node it runs twice

	Now, if plusOne(n) is the other, what is it referencing? 
	- here we are pointing to the temporary object that our compiler created for us, because we actually did not initialize anything
	- so other is a reference to this temporary
		- and the copy constructor deep copies the data from this temporary
	
	But the temporary is going to be discarded anyway, as soon as the statement Node m3 = plusOne(n); is done
	- then why are we copying a temp object if it gets thrown away anyways? 
	- wouldn't it be better if we could steal it instead?
	- it very wasteful to copy from the temp
	  
	Example, one of your friends decided to quit CS246, but they have been taking great notes, whereas you didnt take any. 
	Your friend tells you that you can find the notes in the library, and you like, nah bro if you throw them away, just give it to me.

	The key for this to work is you have to be able to tell, whether other is a reference to a temp or a standalone object
	- up until c++11 this was impossible, but not anymore
	
	Now we rvalue reference Node&& is reference to a temporary object (rvalue) of type Node
	- idea is to copy to lvalue and steal from rvalue
	- for that we have to write a our own contructor

	struct Node {
		Node (Node &&other): 
			data{other.data}
			next{other.next} // now since the list is going to be destroyed because other is a temporary. We actually have to take values away from other
		{ // this is called a move constructor
			// idea is that instead of copying data, it should steal it
			other.next = nullptr; // else the list is destroyed when other is destroyed
		}
	}

	Now we get 
	- 2 basic constructor calls
	- 2 copy contructors 
	- 1 move constructor
	since move is not recursive, it will excecute in constant time always
	** this is one of the trickier concepts in the course, make sure you understand it **

	Since a need for move can arise when using copy operator, it could also arise when using copy assignemmt
	Node m;
	m = plusOne(n); // assignment from temp

	we can also write move assignment operator:
	struct Node {
		Node &operator= (Node && other) { // we want to steal other's data, but its assignent operator now, which means that i already have some of my own nodes
			// so you have to destroy my old data. The other is already going to be destoryed, so you simply swap your data with his data
			swap(other);
			return *this;			
		}
	}

	So if you don't define move constructor/assignment operator, the copy versions will be used.
	if the move constructor/assignment is defined, it will replace all calls to the copy constructor/assignment
	when the argument is temporary (rvalue)


---------------------------Copy/Move Elision-----------------------

	Now he will show us something that will blow our minds.. Great, just what I wanted!

	Consider this function:
	Vec makeAVec() {
		return {0, 0}; // invokes a basic constructor
	} 
	Vec v = makeAVec(); // What runs? copy constructor? move constructor?
	// well, he is not sure, so he is going to ask the compiler.. I didnt know they were that close.
	Only the basic constructor runs, which is pretty messed up
	
	It's a specific behaviour of C++

	In some circumstances, the compiler is allowed to skip calling copy or move constructors (but doesn't have to) // wtf is this?
	In this example: makeAVec writes its result({0, 0}) 
	- idea is that it writes its result directly into the space occupied by V in the caller, rather than copy or move it later
	- though you dont need to know when this stuff happens

	Another Example:
	void doSomething(Vec v) {............}
	Vec v is pass by value // copy or possibly the move constructor
	doSomething(makeAVec()); // the result of makeAVec() is written directly into the parameter.
	// this is allowed even if dropping contructor calls is going to change behaviour of the program (eg. if your constructor prints something)

	Compilers obey something like an ASIF rule // you can do anything you want, as long as its doing something that looks like what you asked.sse
	Lesson: make sure compiler is not confused by your code // you are not expected to know excetly when move/copy elision is allowed, jsut that its possible. 

	If you need all of the contructors to run: g++ can help you
	- g++14 -fno-elide-constructors // will run all of your contructors
	// but we aware how much slower your code becomes. If your compiler is allowed to skip constructors, its probably skiping thousands on them
	// not just one. So your program might slow down by a lot. (if your code is of decent length)

	In summary: Rule of 5 (BIG 5)
	- if you need a custom version of any one of:
		copy constructor
		copy assignment
		destructor
		move constructor
		move assignemnt
	- then USUALLY you need a custom version of all 5
	// circumstances that requre you to change one of them, usually require others to be changed too.

	Notice: operator= is a member frunction, not a standalone function; whereas for Vec it wasn't
	- You usually have the choice to make operator a member or not.
	- when your operator is a member, this is the first argument

	struct Vec {
		int x, y;
		...	
		Vec &operator+ (Vec &other)	{
			return {x+other.x, y+other.y};
		}
		Vec &operator* (const int k) {
			return {x*k, y*k}; // implements v*k			
		}
		// but how do we implement k * v?
		// if the first argument is not Vec, then you write it as a standalone 
	}

	Vec operator+ (const int k, const Vec &v) {
		reutrn v*k;
	}

	Special case of that is when you conside I/O operators

	struct Vec {
		ostream &operator<< (ostream &out) {
		return out << x << " " << y; 
		} // but this will make Vec the first arg;
		// which is somehting you dont want to do for sure	 
	}

	SO DEFINE <<, >> OPERATORS AS STANDALONES

	On the other hand, some operators, by the rules of c++, must be members:
		operator=
		operator[]
		operator->
		operator() // lets you treat objcets as if they were functions
		operatorT // where T is a type. Implicit consversion operator
	
-----------------------------Arrays of objects-------------------------------
Struct Vec {
	int x, y;
	vec (int x, int y):x{x}, y{y}{
		....
	}
}

Vec *vp = new Vec[5];
Vec moreVecs[3]; // these want to call the default constructor on each item, but they can't because there are no default values in Vec cosntructor

Can't initialize arrays of elements.

Options: 
	1) writing a default consturctor
	2) For stack arrays you can do the following:
		Vec moreVecs[] = {{0,0}, {1,3}, {4,5}};
	3) for Heap arrays the best thing to do is to create an array of pointers
		Vec **np = new Vec*[5];
		vp[0] = new Vec{0,0};
		vp[1] = new Vec{1,2};
		// for this method tho, you better remember to deallocate each pointer in the array and also the arrays themselves.
		for (int i = 0; i < 5; i++) {
			delete vp[i];
		}
		delete [] vp;

---------------------------Constant objects-----------------------------------

int f(const Node &n) {...........} // const objects arise often
	// there are many functions that we invoke with constant variables, which means that there are going to be a lot of const objects too

in const objects:
	1) you can't change the fields
	2) Can we call methods on const objects? 
		-> most of the methods can change the fields of the object, which violated const's rules
			-> But whats the point of having const objects if you cant pass them to methods?
				-> so you can call methods on objects, but they have to promise not to change the fields

ex:
struct Student () {
	int assns, midterm, final;
	float grade () const; // here we are making a promise that the method won't change any fields
}
	
So compiler checks that const methods don't actually modify fields and ONLY CONST METHODS can be called on const objects
You have to specify that method is constant in both the header file and the code itself. The way it works is that 
this becomes a const object pointer and you can't change it.


----------------------------Collecting usage statistics------------------------------
Now consider:
	Suppose you want to collect usage statistics on student objects, we want to find out if there is a particular student that is taking up all of our time

	We are going to add a field that for each student will tell me how many times the method is called for a particular student

struct Student () {
	...
	int numMethodCalls = 0;
	float grade () const {
		++numMethodCalls;
		return .....
	}		
}	// but this method is not const anymore, so it will not compile
// you can try removing the const, but then you cant use the code with const objects

and then he says "but but but.. this is what i want, not what i meant"

But mutating numMethodCalls, doesn't impact the student object that is being passed. So we want to make destinction between student and non student objects
	so we have to specify that mutating the numMethodCalls affects only the physical constness of Student objects, not the logical constness.
	
What we want to do is to be able to update numMethodCalls, even if the object is const.
	to do that, you declare field mutable

struct Student () {
	...
	mutable int numMethodCalls = 0;
	float grade () const {
		++numMethodCalls;
		return .....
	}		
}
// mutable fields can be changed, even if the object is const

------------------------Static fields & methods----------------------------------

what if instead of numMethodCalls tracking the number of methods calls for each particular student, we track the method calls over all students
OR
what if we wanted to know how many actual students we have created?
	For this we have the static members - a member that is associated with a class itself rather than a particular object. 

struct Student () {
	...
	static int numInstances;
	Student (int assns, int midterm, int final): assns{assns}, midterm{midterm}, final{final} {
		++numInstances;
	}
} // now there is one field shared between all of the objects, which means that if one of the objects update it, it will update everywhere

But it is not as simple as that:
	basically what we have done is we created a global variable, but within the scope of the class, so it can't be accessed from outside

So if I'm creating a global variable, does this line "static int numInstances;" declare a global variable or define it?
	If it does define it, then we are creating a new variable on every new instance. 
	if it is defined, then we will have way too many copies of the same variable
	if we declare it, then its a question who actually defines it in the first place

So we have to include it in our .cc file:
	int Student::numInstances=0; // in.cc file
Static fields must be defined, external to the class

Now, moving on to the methods:
	static member functions, follow similar set of rules, they dont depend on a specific instance
	- which means that static methods don't have a "this" parameter
	- what can static methods do then? 
		- They can access static fields, because those don't depend on specific objects
		- They can also call other static methods

Ex:
struct Student () {
	...
	static int numInstances;
	....
	static void printNumInstances() {
		cout << numInstances << endl;
	}
};

Student billy {60,70,80};
Student jane {60,70,90};
Student::printNumInstances(); // will print 2
// notice that there is no student attachment, you simply refer to Student struct

----------------------------Intervarians+Encapsulation-------------------------------
struct Node () {
	int data;
	Node *next;
	Node (int data, Node *next);
	....
	~Node() {delete next;} 
}

Node n1{1, new Node {2, nullptr}}
Node n2{3, nullptr};
Node n3{4, &n2};

What happens when these go out of scope?
	- n1 runs its destructor, whole list is deleted OK
	- n2, n3 go out of scope: n3's destructor attempts to delete the n2, but the n2 is on the stack, not the heap
	  and we get undefined behaviour, maybe a crash.

So Class Node relies on an assumption for its proper operation, and the assumption was that next was either a nullptr or allocated by new
 - this is what an invariant is called.
	- this is a logical statement that holds true, upon which Node relies.

But the problem is that while we are relying on it, we can't guarantee that it will be true all the time. You can't trust the user to use it properly
In fact, you cant't enforce any invariants // user can't interfere with our data

Ex:
you are writing stack:
 - Invariant: last item push is the first thing you pop
 - but as long as you give your user access to rearrange the underlying data.
 - this makes your ensuring that your program works very difficult
 - hard to reason about programs if you can't rely on invariants

To enforce invariants, we introduce what is called encapsulation
 - idea is that we want client to see our objects as black boxes, or capsules // something that is sealed away from the user
 implementation details are sealed away, you can only interact via provided methods
 - and thats how we get abstraction and regain control over our objects

Ex:
struct Vec {
	Vec (int x, int y); // by default things are public tho
	private: // stuff under private can't be accessed outside the structure
		int x, y;
	public: // stuff under public can be accessed by anyone
		Vec operator+ (.....);
		.
		.
		.
} 

In general: want fields to be private and only the methods should be public
 - But this is very error prone, so we would instead want to have default visibility as private
	- if the default visibility was private, then all the C will break, because it doesn't have private mode

Then c++ people decided to switch from struc t to class
Ex:
class Vec {
	Vec (int x, int y);
	int x, y;
	public: // stuff under public can be accessed by anyone
		Vec operator+ (.....);
		.
		.
		.
} 

That is the major difference between Classes and Structs, where the default visibility is private
 - so we should use classes from now on

-------------------------Encapsulated Liked Lists----------------------------

Today we want to fix our linked list class

// list.h

Class List { // we want to take advantage of the scoping mechanism of classes
	Struct Node; // we put this inside of list so that its scoped inside a list
	Node *theList = nullptr;
	public:
		void addToFront (int n);
		int ith(int n) const;
		~List () {delete theList};
}
So now we have a nested private class
- only accessible within list
- so the outsiders of this class, can't even use the word Node. All they can do is use the functions that we give them

// list.cc
#include "list.h"

struct List::Node { // nested class
	int data;
	Node *next;
	
	Node (...) {....}
	~Node (...) {....}
};

void List::addToFront(int n) {
	theList = new Node {n, theList};
}

int List::ith(int i) const {
	Node *cur = theList;
	for (int n = 0; n < i && cur; ++n, cur = cur->next);
	return cur->data;
}

Only list can create/manipulate Node objects
- Can guarantee the invariant that next is either a nullptr or allocated by new.

// So this gets the job done to secure creating bad objects with Nodes. But he is not satisfied
// "While we gained here, we have also lost." Thats deep tho...

Now we can't traverse the list from node to node, as we would in a linked list
// now this is not good because it becomes a O(n^2) time.
// we want to access the entire list in constant time, like you would normally.

But we can't expose the nodes, or we lose encapsulation

------------------------------SE Topic: Design Patterns----------------------------

The idea that has come up a lot of times and the solutions that have been studied and proven to work well
- cartain problems that arise frequenty 
- experts keep track of its solutions and reuse the best ones in similar situations
- this is the essence of a Design pattern: If you have problem X, solution Y may fix it

Was coined by 4 individuals who wrote the first book of design patterns
- they studied OOP design and wrote a book about it

So our solution to the problem that we have right now, is known as the interator pattern. 
- the idea is to not to expose the Nodes to keep encapsulation
- we will create another class that will manages the access to Nodes
- this class will be based on the abstraction of a pointer
- we will walk the list without exposing the actual pointers

Inspiration to use this when looping over a list:
for (int *p = a; p != a+n; ++p) {
	....*p..... // access the item using the pointer
}

Class List { // we want to take advantage of the scoping mechanism of classes
	Struct Node; // we put this inside of list so that its scoped inside a list
	Node *theList;

	public:

		class Iterator {
			Node *p;

			public:
				explicit Iterator(Node *p): p{p} {......}
				int  &operator*() { // the fact that this returns the reference means that we don't get a copy of the list, but the list itself.
									// so we can actually modify it later
					return p->data;
				}
				int &operator++() {
					p = p->next;
					return *this;
				}
				bool operator== (const Iterator &other) {
					return p==other.p;
				}
				bool operator!= (const Iterator &other) {
					return !(*this==other);
				}
		} // end of the iterator class
		// this is not the end, we still have to make methods that will tell us where is the start and where is the end of the list

		Iterator begin() {
			return Iterator{theList};		
		}
		Iterator end() {
			return Iterator{nullptr};
		}

		void addToFront (int n);
		int ith(int n) const;
		~List () {delete theList};
}


Client:
-------
int main() {
	List l;
	l.addtoFront(1);
	l.addtoFront(2);
	l.addtoFront(3);

	for (List::Iterator it = l.begin(); it != l.end(); ++it) {
		cout << *it << endl;
	}
}

// Most importantly, we keep the encapsulation
// and we get all of the operations in O(1)
// which means that this iteration of the list is O(n)

If you have an objection that this is way too much stuff to write down, then we will see some shortcuts now

AUTOMATIC TYPE DEDUCTION:
auto x = y; // idea is that im too lazy to write out the type for x;
// but since we know that x is being initialized to y, we will simply match their types
// auto has existed for a long time, but noone used it, so they recycled it for a new purpose
// auto used to be the opposite of static, meant that variable was on the stack, but all of the variables are on the stack by default
// so now auto has a new meaning.

Using automatic type deduction:
for (auto it = l.begin(); it != l.end(); ++it) {
	cout << *it << endl;
}

RANGE-BASED FOR LOOP:
for (auto n:l) {
	cout << n << endl;
}
// this is available for any class with methods begin(), end() that produce Iterators
// Iterator must support !=, ++(prefix), unary *

The only thing is that n is by value declaration, so n is the copy of the list, so you can change the n, but not the list.

If you actually want to modify list elements, or save copying memory:
for (auto &n:l) {
	cout << *n << endl;	
	++n;
} 

!!!!!Iterators is a big topic in C++, you have to really understand those!!!!!

Coming back to ENCAPSULATION: there is still one little loophole that we have to close
We dont want clients to create their own Iterators

List client can create Iterators directly
- the only iterator they can create is null one
auto it = List::Iterator{nullptr};
- this violates encapsulation, client should be using begin(), end()

We can make the Iterator's constructor private for this purpose:
- then the client can't call List::Iterator(.....)
- but this also menas that List can't call it

Solution we are looking for is to give List priveledged access to Iterator
- you make List a friend

Class List {
	Struct Node;
	Node *theList;

	public:
		class Iterator {
			Node *p;
			explicit Iterator(Node *p): p{p} {......}
			
			public:
				int  &operator*() { 
					return p->data;
				}
				int &operator++() {
					p = p->next;
					return *this;
				}
				bool operator== (const Iterator &other) {
					return p==other.p;
				}
				bool operator!= (const Iterator &other) {
					return !(*this==other);
				}
				friend class List; // list has access to all members of Iterator
				// can also make a specific member of a class a friend too, but we will cover that later
		}

		Iterator begin() {
			return Iterator{theList};		
		}
		Iterator end() {
			return Iterator{nullptr};
		}

		void addToFront (int n);
		int ith(int n) const;
		~List () {delete theList};
}

So now List can still create Iterators, but the client can only create them by calling begin() and end()
look into the repository for an example: "~/cs246/1169/lectures/se/"
// wow this shit is mindblowing

ADVICE: you want to make as little friends as possible
// only make a friend that can do something for you otherwise it will weaken encapsulation and changing one thing will make you change everything
// Lushman's advice for life..

ONCE AGAIN:
- Keep your fields private 
- what if you want to give access, use accessor and mutator methods

Ex:
class Vec {
	int x, y;
	public:
		int getX() const {return x;} // accessor method
		void setY(int newY) {y= newY;} // mutator method
};
// This way you keep control of the structure and can validate parameters that are being passed

What about the operator<< 
- needs x, y
- can't be a member
- if you don't want to give access to getX(), getY() to everyone

You should then make operator<< a friend function
// vec.h
class Vec {
	.....
	public:
		friend std::ostream &operator<< (std::ostream &out, const Vec &v) // this is a friend intialization, you can still customize the &operator<< function
	.....
};

// vec.cc
ostream &operator<< (ostream &out, const Vec &v) {
	return out << v.x << ' ' << v.y;
}

-----------------------------Tools topic: Make-------------------------------
Separate compilation:
- g++14 -c list.cc
  g++14 -c node.cc
  g++14 -c iter.cc
  g++14 -c main.cc
  g++14 list.o, node.o, iter.o, main.o -o myprogram
- we do this so we dont have to recompile
- once you move on to bigger projects, you dont want to recompile every single file

But how do you know what has to be recompiled?
- use technology bruh, with make

What make does, is it keeps track of what parts of your programs needs to be changed
- it needs a makefile
- but then compilation is 10000000000000000000 times faster and more convenient

Create a makefile that says which files depend on which other files

Ex:
what myprog depends on: 
	main.o, list.o, node.o, iter.o // idea is that my program depends on these and if any of those change, we have to rebuild
how do you rebuild it: 
	g++-5 -std=c++14 main.o, list.o, node.o, iter.o -o myprog // NOTICE: you have to start this line with TAB, not Spaces

class Test:public Book {
	public:
	Text(string title, string author, int numPages, string topic): Book{title,author,numPages}, topic{topic} {} 
}

// Rule: if the super class had no defult constructor, subclass must invoke the superclass constructor in its MIL

still you may be thinking it is a litttle strange that the superclass fields are not visible for subclass, he will explain it later
and if you want to give the subclass access to certain superclass members, there is a way to do it:
	- you use protected visiblity
	
class Book {
	protected: 
	string title, author;
	int numPages;
};

class Text:public Book {
	string topic; // since authors can change we need create a method for that
	public:
	void addAuthor(string auth) {
		author += auth;
	}
} // although this is occaionally useful, its usually not a good idea to give subclassses unlimited access to fields

So why is it a bad idea? even though its protected? 
 - suppose you keep a collection of your book and suppose that you ust hate one author so much
 - You dont want to have any books by that author. You provide an inveriant that removes all appearences of that authors name
 - then, you can protect your class all you want from the bad author, but if your subclass can change fields of the class, then
   you have broken encapsulation because i will be able to change the author name of the existing classes

Author of C++ has regretted adding protected!!

But if you do want your subclass to access certain fields sometimes? 
 - make sure you make your fields private and provide protected methods that do your getting and setting
 - this way you still have control of what users can do and you can still enforce your invariants

class Book {
	string title, author;
	int numPages;
	protected:
	string getTitle() const;
	void setAuthor(string auth);
	public:
	Book();
	bool isItHeavy() const;
}

-----------------------------Relationship among text, Book called 'is-a'-----------------------------
 - a text is a book
 - a comic is a book

	       Book 	
			|
	-----------------
	|				|
   text           comic

Method isItHeavy - when is a book heavy?
 - for ordinary Books -> 200 pages means heavy
 - for textbooks (text) -> 500 pages means heavy
 - for comics -> 30 pages means heavy

So we go ahead and write our class Book

class Book {
	protected:
	int numPages; // although not a good idea, we will do it this time
	public:
	bool isItHeavy() const {
		return numPages > 200;	
	}
}

class Comic: public Book {
	public:
	.....
	bool isItHeavy() const{
		return numPages > 30;	
	}
}

Now lets use these objects:
Book b{"A small book", "...", 50};
Comic c{"A big comic", "...", 40};

cout << b.isItHeavy() // false
	 << c.isItHeavy() // true

now comes the interesting part
	- we said that inheritance type of 'is-a'
	- and if comic is a book ,then there are certain things we can do

Book b = Comic{"A big comic", "...", 40}; // initializing a books using a comic object
// this is allowed, but its not what we want

Q: is b heavy now? or another way of saying it, which version of isItHeavy() runs? (Comic's method or Book's method)
A: b.isItHeavy() will give you false, book's isItHeavy() runs

Now the question is Why? 
A: imagine what happens in memory when we do this
Book will look something like this:
 - title
 - author
 - numPages
And the comic book is going to look like this:
 - title
 - author
 - numPages
 - hero

the compiler has enough space to only keep a book
	- so what we are trying to do is to fit an object with 4 fields into a hole of 3 fields
		- trying to fit a comic object where there is oly space for a book object
	- at this point you lose the field hero and then you simply treat your comic as a book

This phenomenon is called SLICING // the hero field is chopped off and comic is coerced into a book

so b = Comic {...};
 - converts comic into a book and so Book::isItHeavy() runs
// if this was the other way, then we'd have memory leaks all the time

Q: Now you may wonder, what if the comic has the same amount of fields as the Book?
A: yes, as long as you initialize super class using a cublass, it will be sliced anyways and the superclass' members will run

Q: Can you initialize a comic with a book? 
A: the question then is who is the hero? and since you can't answer this, no you can't

Q: what constructor gets called? 
A: "I suppose its actually a move constructor"

This idea is based around limited memory spaces, but if we work with pointers, things change all of the sudden, because we dont move memory around as much
 - when accessing objects through pointers
 - slicing is uneccesary
 - and it doesn't happen

Ex:
Comic c {..., ..., 40, ...};
Book *pb = &c;
Comic *pc = &c;

cout << pc->isItHeavy() // true
	 << pb->isItHeavy() // false

 - Still, it shows that its not heavy and this time there was no slicing, we created a comic book and just pointed two pointers at it
 - Same objects behaves differently depending on what kind of pointer is pointing at it

Q: So what is the rule? what determines what method is run?
A: The compiler is using the type of the pointer or refrence to decide which isItHeavy() to run
	- it does not consider the actual type of the object

And in many ways, this outcome is unintuitive, it means a comic is only a comic if it is pointed at by a comic pointer
// might not be what we want

Imagine you sitting on your bed and pick up a heavy comic
 - you dont say that oh this is a light comic that im viewing as a book
 - you say oh, its a heavy comic

How do we make comic, even when pointed at by a book?
 - Declare the method VIRTUAL!

class Book {
	....
	public:
		Book(....);
		virtual bool isItHeavy() const {.....};
};

// and then in your subclass

class Comic:public Book {
	....
	public:
		Comic(....);
		bool isItHeavy() const override {....};
}

// Now, if we do the same thing:
Ex:
Comic c {..., ..., 40, ...};
Book *pb = &c;
Book &rb = c;
Comic *pc = &c;

cout << pc->isItHeavy() // true
	 << pb->isItHeavy() // true
	 << rb.isItHeavy() // true

Override is new in C++ // only since v.11

Ex:
Book *myBooks[20];
.
.
.
for (int i = 0;, i < 20, i++) {
	cout << myBooks[i]->isItHeavy() << endl;
}

Accomodates multiple types under one abstraction -> POLIMORPHYSM ("many forms")

Now that we have inheritance, we have to redo all of the BIG 5

-----------------------Inheritance: Destructor------------------------

class X {
	int *x;
	public:
		X(int n): x{new int[n]} {}
		~X() {delete [] x}
};

class Y: public X{
	int *y;
	public:
		Y(int m, int n): X{n}, y{new int[m]}
		~Y() {delete [] y;} // notice how we don't delete X, even though it inherits it. 
};

Q: Not deleting X, is that wrong?
A: There is a big problem if we did have a leak, because x is private in X
	- when you create an object, the super class constructor runs first
	- when you destroy an object, the superclass destructor runs last

What if we do this now? 
Ex:
X *myX = new Y{10, 20}
delete myX;
// he ran it and nothing crushed
// he ran it with valgrind and found a memory leak
// only x was freed, not the y

He deleted x poitner and x's destructor ran. But he destructor for y didn't run // since its a subclass of x
 - so we didnt have a problem, when we deleted x, through y's destructor
 - but we do have a problem when we delete y using x's destructor // because y is not a superclass of x

Q: How do you make sure that the deletion through the superclass will call subclasses' destructor?
A: Make the destructor virtual

class X {
	int *x;
	public:
		X(int n): x{new int[n]} {}
		~X() virtual {delete [] x}
}; // you dont have to add override to the destructor in Y

So there is a piece of advice:
 - ALWAYS make the destructor virtual in classes that are meant to have subclasses
 - this is true, even if the destructor is not doing anything (has an empty body)

On the other hand, if a class is not meant to have subclasses, declare it final:

class Y final:public X {
	....
	....
	....
}


---------------------------Pure Virtual Methods + Abstract Classes-------------------------------

class Student {
protected:
	int numCourses;
public:
	virtual int fees();
}

2 kinds of Student: Regular + Cooop

class Regular:public Student {
pblic:
	int fees() override;

} // regual student's fees

class Coop:public Student{
public:
	int fees() override;

} // coop student's fees

what should we put for Student::fees?

Not sure, every student should be regualr or co-op

Can explicitly give Student::fees No implementation

class Student {
....
public:
	virtual int fees() = 0; // methos has no implementaion ****
	// called a pure virtual method
}

A class with a pure virtual methods cannot be instantiated:
Student s; // will not work

this is called an abstract class and its purpose is to organize subclasses

Subclasses of an abstract class are also abstract, unless they implement the pure virtual methods.

If a class is anot acstract, then its concrete

UML: Virtual + pure virtual methods::italics

static _____ underline

At this point of time, we usually play how imheritance plays off the BIG 5, but instead he is going to focus on the assignment

-------------------------------------Templates-------------------------------------------

This is very big in C++, but we are going to spend very little time on this

Earlier on, we had something like this:

class List {
	struct Node;
	Node *theList;
	.....
};

struct List::Node {
	int data;
	Node *next;
}
we went to a lot of trouble to implement this, and all was good because we got it to work.
Q: But what if we now want a string linked list?
Q: do we have to write a whole new class, now?
A: Yes, we do, but C++ can help us, if we create a template class parametized by a type

template <typename T> class Stack {
	int size;
	int cap;
	T *contents;
	public:
		Stack() {.......}
		void Push(T *) {.......}
		T Top() {.....}
		void Pop() {......}
} // now istead of using an int everywhere, we use a pointer to contents

template <typename T> class List {
	struct Node {
		T data;
		Node *next;
	}
	Node *theList;
	public:
		class Iterator {
			Node *p;
			explicit Iterator(Node *p): p{p} {}
			public:
				T &operator*() {return p->data;}
				....
				....
				....
		}
	T ith(int i) {....}
	void addToFront(T n) {....}
} // the idea is instead of specifying what type of data is returned in every method, we will simply say T

The benefit is that now our client can say:
List<int> l1;
if we want a list of lists of int:
List<List<int>> l2;

l1.addToFront(3);
l2.addToFront(l1);

This list template still has a begin/end method and and interator class, so we can still iterate it, the way we did before:

for (List<int>::Iterator it = l1.begin(); it != l1.end(); ++it) {
	cout << *it << endl;
}

or indeed, what we did before, still applies:

for (auto n:l1) {
	cout << n << endl;
}

Every time we create a new class using templates, we are actually creating brand new classses, it's just that we don't see it anymore

"this is some things about c++, it starts relatively easy, with strings and other bs and then you get into writing your own assignment operator." 
"Suddenly, c++ will get really difficult, but there comes a point where difficulty level slows down. Right now we are going to hit a crest, where its not as difficult"

-------------------------------------------The standard Template Library (STL)--------------------------------------
much of the stuff that comes with C++ is written out as templates, so you can resue it for your own purposes

Large # of useful templates:
Eg: dynamic-length arrays : VECTORS
	In the next assignemnt (4), it says you are not allowed to use array's functions delete and new, because they want us to use this:
	vectors will manage all the heap allocated arrays for you

#include <vector> // we have to be a little bit careful here
using namespace std;

// recall the curly brackets vs. round brackets argument
// in generall curly is for c++ and round for c, so you shoul dbe using curly 99% of the time
// except for this time, tho. ik, its ucked up

vector<int> v {4, 5}; // gives you a vec(4, 5)
vector<int> v (4, 5); // gives you a vec(5, 5, 5, 5)

// The {} expression is called the initializer list
// if you write a function that takes in {}, you can intiialize arrays using that

v.emplace_back(6);
v.emplace_back(7); // now we have (4, 5, 6, 7)
// we can do this forever and the array will keep growing forever and this array is also STACK allocated
// DAMN SON, someone give Lushman a cookie

Looping:
Eg:
for (int i = 0; i < v.zise; ++i) {
	cout << v[i] << endl;
} // just like an array, the vector standard guarantees that its going to behave as an array

for (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
	cout << *it << endl;
} // also can use auto here

OR:

for (auto n:v) {
	cout << n << endl;
}

Wow, he brouoght up the midterm...

To iterate in reverse:
for (vector<int>::reverse_iterator it = v.rbegin(); it != v.rend(); ++it) {
	cout << *it << endl;
}

v.pop.back() // remove last element

Use iterators to remove from inside a vector:
	auto it = erase(v.begin()); // erases element 0
	it = v.erase(v.begin() + 3) // erases item 3
// vectors' interators support pointer arithmetics
// not all interators are created equal, so not all of them can do it 
// One of the rules that comes to vectors, when you use anything that shuffles items around (deleting elements),
// you shold not be using iterators with deletion of elements

instaed, use this:
it = v.erase(it); // erases item pointed at by it
it = v.erase(e.end() - 1); // returns an iterator to the item past the item jsut removed.

Now that we are allowed to use vectors, we should emprace them... We have just eliminated an entire class of memory management

v[i] - returns the ith element of v // this method call is completely unchecked, just like with arrays
// if you go out of bounds, you are in for some fun behaviour
// might prefer using iterators, because those never go out of bounds

on the other hand, there is another version of iterator that is checked:
v.at(i);

Q: what happens when you break the rules and try going out of bounds with .at()?

Problem: 
	- Vector's code can detect errors, but it doesn't know what to do about it
	- Only the client can respond on how we should behave here, but they can't detect the error

C solution:
	- if a function fails, it returns status code
	- set the global variable "errno" to an error code, but then you are supposed to check it all the time, but ain't nobody got time for that
	// now we have this entire mess that discourages programmers to do error checks, because they are inconvenient

C++ solution:
	- when an error condition arises, the function raises an exception. By default, execution stops
	- but you can also write HANDLERS to CATCH exceptions "because apparently they are like baseballs"

vector<T>::at() raises an exeption std::out_of_range, when it fails
// we can handle it as follows

#include <stdexcept>
.....
try { // inside the curly brackets go the statemnts that might faild due to specified error
	cout << v.at(1000000000000) << endl;
} catch (out_of_range r) {
	cerr << "Range error: " << r.what() << endl;
} // you are allowed to ask what? Which will give you some extra info on the error


----------------------------Exceptions------------------------
Now consider:
void f () {
	throw out_of_range{"f"} // "f" is what()
}
void g() {f();}
void h() {g();}


What happens:
	- main calls h
	- h calls g	
	- g calls f
	- f throws out_of_range

// enter more here


A handler can do part of the recovery job // execute some corrective code
 + raise another exception

try {...}
catch (Some_type s) {
	...
	throw Some_other_error {"..."}; // can be the same one
}


Throw VS. Throws:
	Since exceptions are classes, we can also have subclasses
	class SomeType {
		class SpecialSomeType {
		...
		}
	}

"This is similar to pass by reference vs. pass by value"
Throw: actual type of s is retained 
// ^pass by reference

Throws creates a new exception of type SomeType, even if s itself was already specialtype
// ^pass by value

Occasionally, you want to say, idc what type of error it is, i simply want to catch it
- No, you cant do that 
// there is a top level exception type, and all the otehr types inherit from it 
- but you might still want to do it, but how? 

"A handler can act as a catch-all":
try {....} // these dots stand for the code
catch (...) { // you must put the three dots in to catch all exceptions, like "..."

}

Apparently exceptions that you throw, don't actually have to be objects, so you 
can't call .what() on all of them, because they simply dont have that method

check as SICK example of recursion, factorials and throwing errors in 
lectures/c++/exceptions/exfact.cc
	OR
lectures/c++/exceptions/exfib.cc

new helper thing in Ubuntu:
	time ./myprog // to see how long the program takes
	- you look for "user" for acutal time of your code
	- "real" means how long you took to run your ptogram

Ok so he did the following:
	- he timed his recursive fibonacci sequence and timed his exfib.cc function
	- the recursive ran in 0.018s and the one with exceptions took 11.716s

Moral: "dont overuse exceptions! they might be useful, when you actually need them tho"

Now we will learn how to define our own exception class: 
Eg:
class BadInput {};

try {
	int n;
	if (!(cin >> in)) therowBadInput{};
} catch (BadInput &s) {
	cerr << "input not well-formed" << endl; 
	// HE caught the exception by reference this time and in general thats what you
	// should always do
}

Q: why catch by reference? 
A: 
- supresses copying
- exception that you caught might be a subtyoe and you dont want it to be sliced
- its the proper way to work with objects

Some standard exceptions:
- length_error // attempting to resize strings/vectors that are too long
- bad_alloc // is what happens when "new" fails
// remmeber how he told us that sometimes new fails? 
// if it fails, it throws an exception, which if not handled, will crash the whole program

Much more on exception later! // good enough for A4

We are going back to Design Patterns

------------------------------Guiding Principle---------------------------------
Guiding principle: program to the interface, not the implementation:
- You start with an abstract base class, to define the interface
- You work with pointers to  abstract base classes and call their methods
- Concrete classes can be swapped in/out
- It gives you abstraction over variety of behaviours

Lets get back to the interator pattern:
Eg:
class List {
	Struct Node;
	...
	public:
		class Iterator {
			....
			....
			....
		};
	...
}; // what if you want to iterate over other object
// you can try writing a class called abstract Iterator
// where you will put all the things that you want

class AbstractIterator {
	public:
		virtual int &operator*() = 0;
		virtual AbstractIterator $operator++() = 0;
		virtual bool operator!= (const AbstractIterator &other) =0;
		virtual ~AbstractIterator();
};

// now what he can do is this? 
// what if he has another data structure? 

class set {
	....
	public:
		class Iterator:public AbstractIterator {
			....
			....
		};
	....
};

// if you still saying "So what?" here is what he does next

What if you want to write a function that will print all the items out of the list?
	- but instead of giving it out list, we give it an interator

Then you can write code that operates over Iterators
Eg:
void foreach(AbstractIterator start, AbstractIterator end, void(*f)(int)) {
	while (start != end) {
		f(*start);
		++start;
	}
}; // works over lists and sets

This is the main thrust behind the design patterns, where you can have abstract classes
so that you can have concrete behaviour for every operation and never make mistakes

Another Design Pattern coming up now!!!

---------------------------Observer Pattern------------------------------------
Very useful, might get a lot of milage on A4 and A5

Idea of Publish-subscribe model:
- you have one class: publisher/subject, which generates data
- one or more subscriber or observer classes, which receive data and react to it

Eg:
- your publisher is an excel spreadsheet
- your observers are graphs
	- idea is that when the sells change, the graphs update

Can have all kinds of observer objects:
	- observer attached to a cell of a spreadsheet, which notifies you when values go < 0
	
since there are so many possibilities you can't code it wrong
- you should make it so that it works all the time and wont care who the observer is
- subject should not need to know all the details

Observer pattern:
- we start with abstract classes:
- idea is that subject has observers
- it has them, but doesn't own them
- UML diagram will be uploaded in the folder git_notes/

sequence of method calls:
1) Subject's state is updated
2) Subject's Notify observer must be called // calls each observer's notify
3) Each observer calls ConcreteSubject::getState to query the state & reach accordingly

Example: Horse Races
- subject: big scoreboard in the middle of the field that tells you who is winning
- observers: individual betters 
			- declare victory when their horse wins

Lets write this // damn son

class Subject {
	vector<Observer*> observers;
	Subject() {};
	bool sttach (Observer *o) {observers.emplace(o);}
	void detach (Observer *o) {...} // take observer out of the list
	void notifyObservers () {
		for (auto &ob:observers) ob->notify();
 	}
	virtual ~Subject() = 0;
}

Now, we have a problem // he points to the subjcet class
"This class is not abstract, it doesn't have any vitrtual methods"
"Here is the trcik if you want abstract class and dont have any methods that are virtual"
"You make the destructor pure virtual"

NOTE: a virtual destructor must always be implemented!!!!

Subject::~Subject() {...};

Why? because when destrcutor is run, the super class destructor will be called, so it better exist


Now we are actually writing out the Observer Pattern

class Subject {
	vector <Observer*> observers;
	public:
		void attach(Observer *o);
		void detach(Observer *o);
		void notifyObservers() {
			for (auto &ob:observers) ob->notify();
		}
		virtual ~Subject() = 0;
}
Subject::~Subject() {}


public Observer {
	public:
		virtual void notify() = 0;
		virtual ~Observer();
};
Observer::~Observer() {};



class HorseRace: public Subject {
	ifstream in; // source of data
	string last_winner;
	.
	.
	.
	public:
		HorseRace(const string &source): in{source} {}
		bool runRace(); // set last winner
		// need a bool because you want to know when there are no more winners
		// read in winners, if it read it successfully, return true, else false
		string getState() {return lastwinner;}		
}

class Better:public Observer { // every better has a race that they are watching
	HorseRace *subject;
	String name, myHorse;
	public:
		Better(...) { // easy one, just set your hourse's name and notify the subject that we are watching it
			subject->attach(this); // puts this into the list of observers in Subject		
		}
		~Better() {subject->detach(this);}
		void notify() {
			String winner = subject->getState();
			if (winner == myHorse) {
				cout << "YAY!" << endl;
			} else {
				cout << "Double or nothing" << endl;		
			}
		}
}

// how we do the main.cc
HorseRace hr;
Better Larry(&hr, "Larry", "RunsLikeACow");
....
while (hr.runRace()) {
	hr.notifyObservers();
}

The key to this pattern is that it doesn't have to be about horse racing, it can be about anything
Where you are simply watching the state of a class and notify others when it changes and 
do things accordingly to those changes

---------------------------------Decorator Pattern------------------------------------

Want to enhance Object at run-time-add functionality/features

Eg:
Window system:
	- Start with a basic Window
	- Lets say that you typed so much text into that window that you need more space
	- Then a scroll bat suddenly appears
	- then you move your cursor to the top of the screen
	- and the menu bar appears too

Idea is that these things change at runtime and we want to take advantage of that
 - This is called decorator pattern

// the UML Diagram

Class component:
	- defines the interface
	- operations your objects will provide

Concrete Component:
	- implements the interface

Decorators:
	- all inherit from decorator, which inherts from component

So, every decorator is a component, "AND" every decorator "HAS" a component

Here is a key ho this all fits in with a window:
 - A window with a scroll bar is a kind of window and has a pointer to the underlying plain window
 
 - Similarly, a window with a scroll bar menu is a window and has a pointer to a window with a scroll
	bar, which itself has a pointer to a plane window

 - All of these inherit from an abstract Window class, so the window method can be used polymoprhically
	on all of them // you could describe it as similar to stack logic

Eg of the decorator pattern, called Pizza

// insert diagram here

// open diamon means aggredation, means hasA, not ownsA

 - Basic Pizza is crust and sauce

class Pizza {
	public:
		virtual float price() const = 0;
		virtual string desc() const = 0;
		virtual ~Pizza();
}

class CrustAndSauce:public Pizza {
	public:
		float price() const override {return 5.99;}
		string desc() const override {return "Pizza";}
};

class Decorator:public Pizza {
	protected:
		Pizza *component;
	public:
		Decorator(Pizza *p): component{p} {}
		virtual ~Decorator() {delete component;} // ? tho
		// the question is should the component supposed to delete the component underneath itself? 
} // for now we will say that we can't remove toppings from a pizza

class StuffedCrust:public Decorator {
	public:
		StuffedCrust(Pizza *p): Decorator{p} {}
		float price() const override {
			return component->pricE() + 2.69;
		}
		string desc() const override {
			return component->desc() + " with stuffed crust";
		}
};

so in your main, you will have something like this:
// main.cc

Pizza *p1 = new CrustAndSauce;
p1 = new Topping("Cheese", p1);
p1 = new Topping("Jelly Beans", p1);
p1 = new StuffedCrust(p1);

cout << p1->desc() << ": " << p1->price() << endl;
delete p1;

And we are done with the decorator pattern and FML


-----------------------------------Inheritance in the BIG 5-----------------------------------------
Now we are going to go back and have a discussion about the BIG 5 and inheritance

We have already seen the destructor that was inherited, what about the other ones tho?

we got a class book..

----------------------------------Inheritance and Copy/Move-----------------------------------------

class Book {
	// deifnes copy.move constructors, copy/move operator=
}

Then we inherit it in a subclass..
	 But suppose we do not define copy and move in the subclass..

class Text:public Book {
	....
	public:
		// Does not define copy/move operations
}

Text t {"Algorithms", "CLRS", 500, "CS"};
// so what happens when we do this?
Text t2 = t; // remmeber we have not defined copy/move operations for Text

Remember: copy constructor is given to you for free.. 
 - calls Book's copy constructor
 - then goes field by field (i.e. default behaviour) for Text part
 - same for other operations

// this is good because you kind of want this to happen.. but there are a few things that we have to know

Suppose you actually want to write move/copy operations for your subclass, how would you do that?

To wirte your own operations:

Copy constructor:
Text::Text(const Text &other): Book{other}, topic{other.topic} {} // copy constructor

Copy Assignment operator:
Text &Text::operator= (const Text &other) {
	Book::operator=(other); // we want to use the one in Book
	topic = other.topic
	return *this;
} // copy assignment


Move constructor:
Ver 1.0
Text::Text (Text &&other): Book{other}, topic{other.topic} {} // this is wrong
// notice &&other is an lvalue that points to the rvalue of the other
// we are not taking advantage of the move constructor's efficiency because we are actually using a copy
// constructor from the Book

Ver 2.0
Text::Text (Text &&other): Book{std::move(other)}, topic{other.topic} {} // this is strill wrong
// because other.topic is also an lvalue that is pointing to the rvalue
// so again, we are copying it instead of moving it, so we have to fix that

Ver 3.0
Text::Text (Text &&other): Book{std::move(other)}, topic{std::move(other.topic)} {} // this is correct

Move Assignment operator:

Ver 1.0
Text &Text::operator= (Text &&other) {
	Book::operator=(other); // this is a copy assignemnt
	topic = other.topic; // this is a copy assignement
	return *this;
} // we actually want other to be treted as an rvalue, so we have to change something

Ver 2.0 
Text &Text::operator= (Text &&other) {
	Book::operator=(std::move(other));
	topic = std::move(other.topic);
	return *this;
} // this is a correct version

Notes:
 - even tho other points at an rvalue, other itself is an lvalue and so is the other.topic
 - std::move(x) forces an lvalues x to be treated as an rvalue, so that the move version of the operations run
 - everything we have done here is equivalent to the default, so if you want to do default things, then
	you dont have to change anything, you are given these things for free



----------------------------------------Partial Assignment-----------------------------------------
Text t1 {...}, t2 {...};
Book *pb1=&t1, *pb2=&t2;

What if we do this? 
*pb1 = *pb2; // so we are assigning text2 to text1 through a book pointer

so what happebed is that only the book part was copied over, and the text topic did not copy
 - This is called partial assignment // it is not slicing tho
	// we are not trying to fit a large object into a small hole

Why was only the book part copied? 
 - only the book assignment operator ran
 - since we were using the book pointers

How can we fix this?
 - we want to stop using pointer to decide which assignment operator runs
 - try making operator= virtual

class Book {
	...
	public:
		virtual Book &operator= (const Book &other) {....}
};

class Text {
	...
	public:
		Text &operator= (const Book &other) override {...}
		// we have to use Book here in order to override the operator, otherwise it wont be an override
}

Note:
 - the different return types are OK (as long as return a subtype by reference)
 - but the parameter types must be the same or its not an override. And won't compile
 - parameters not macthing => violates is-A

Making virtual operator= forces us to take any book as the second part of the operator=
 - this means that assignment fo a Book object to a Text var would be allowed:
Eg:
Text t{..};
Book b{...};
Text *pt = &t;
Book *pb = &b;
*pt = *pb; // uses a book to assign a Text, which is very BAD!!!
// but it will still compile tho.. 

Also:
Comic c{...};
Comic *pc = &c;
*pt = *pc; // even worse, we can assign book as a comic

if operator= is non-virtual
 - you get partial assignment through base class pointers
 - if it is virtual, then the compiler allows to mixed assignment
"No matter what choice you make, traouble awaits.."  -- Brad Lushman, 2016

Whats the solution?
 - is a text really a book?
 - is comic really is a book?
 - we said for example, all books are heavy if they are over 200 pages, and textbooks heavy over 500 pages
 - so they are kind of different
 - we have been treating our super class book as a specific class rather than a super class
 - Recommendation: all super-classes should be abstract!

He suggests we rewrite the hierarchy
// insert the diagram for new book hierarchy

class AbstractBook{
	string title, author;
	int numPages;
	protected:
		AbstractBook &operator= (const AbstractBook &other); // prevernts assignment through base class
		// pointers from compiling, but still makes the implementation available to sublasses
	public:
		AbstractBook(...);
		virtual ~AbstractBook() = 0;
}

class NormalBook: public AbstractBook {
	public:
		NormalBook(....);
		~NormalBook(...);
		NormalBook &operator= (const NormalBook &other) { // now we dont have to override like we did b4
			AbstractBook::operator=(other);
			return *this;
		}
};

// to finish other classes, its an excercise for us

So can you do partial assignment now? 
operator= is not virtual, no mixed assignment

NormalBook n1 {...}, n2 {...};
AbstractBook *pa1 = &n1, *pa2 = &n2;
*pa1 = *pa2; // won't compile

// but our abstractBook operator= is protected, so the client cannot use it..
// the code will not compile
// so no partial assignment either, because operator= is protected

Recommendation: Always make your classes that you inherit from abstract
 - you should have an emply shell class and then Phill it up // $2.25 shots at Phill's

---------------------------------Factory method pattern--------------------------------------------
scenario: We are writing a video game
 - there are two types of enemies..
 - turtles and bullets
 - idea being turtles are easier to beat than bullets
 - system randomly sets turtles and bullets
 - but bullets become more frequent closer to the end

// insert uml here

Idea is that you never know exactly which enemy is comes next, so can't call turtle/bullet 
constructors directly
 - instead of calling constructors directly
 - we put a factory method in level that creates enemies

class Level {
	public:
		virtual Enemy *createEnemy () = 0; // factory method
		...
};

class NormalLevel: public Level {
	public:
		Enemy *createEnemy() override {
			// create mostly turtles
		}
};

class Castle: public Level {
	public:
		Enemy *createEnemy() override {
			// create mostly bullets
		}
};

// then the client:
Level *l = new NormalLevel;
Enemy *e = l->createEnemy(); // we dont actually know what enemy we get, but we know that it will
// be chosen based on the rule that is created inside the appropriate level


-----------------------------------Template Method Pattern-----------------------------------------
want subclasses to override superclass behaviour, but some aspects must stay the same.

Eg:
There are red turtles + green turtles

class Trutle {
	public: 
		void draw() { // only draw() is the template method
			drawHead();
			drawShell();
			drawFeet(); // the only difference between green and red turtle are their shell colours
		}
	private:
		void drawHead();
		void drawFeet();
		virtual drawShell() = 0;
};
// the sublclasses dont get to decide what it means to draw a turtle, they can only decide on
// what the tutle's shell will be
The overall behaviour cannot be changed, but we can fill in certain blanks that we give access too
Note: 
	sublass can't call drawShell() because its private, but it can still override it tho, to adjust
	the colours

class RedTurtle:public Turtle {
	void drawShell() override { /*draw red shell*/ }
};

class GreenTurtle:public Turtle {
	void drawShell() override { /*draw green shell*/ }
};

Sublasses dont have the power to change what it means to draw a turtle (i.e. head, shell, feet)
but they can change the way the shell is drawn

Apparently the template method is the most common template ever and is always encouraged
to be used everywhere

Extension: the Non-virtual Interface (NVI)
 - a public virtual method is really two things:
	- saying to a clint, here is a function you can call and this is what it will do
		(a.k.a. interface to the client, with pre/post conditions)
	- you are saying to a subclass, you can do anything you want here
		(a.k.a. interface to subclasses, a "hook" to insert specialized behaviour)
	// these two things don't match together very well

Hard to separate these ideas if they are tied to the same functions..
 - what if you later want to separate the customizable behaviour into two functions?
 - thats when you make your pure virual methods pure virtual
 - this way the client won't have to worry about changing behaviour
 - while sublclasses can override to customize method for their purposes

 - how can you make sure that overriden functions conform to the pre/post conditions

The NVI idion says:
 - "all public methods should be non-virtual"
 - "all virtual methods should be private or at least protected"
 - one exception, the destructor must always be public

Eg:
class DigitalMedia {
	public:
		virtual void play() = 0;
};

to turn it into an instance of NVI, write it like this:

class DigitalMedia {
	public:
		void play( doPlay(); ); // can add before/after code
		// check copyright before playing
		// update the play count after the thing has been played
	private:
		virtual doPlay() = 0;
} // now what client looks at and what subclass looks at are different
// client can still play with consistent behaviour
// subclass can override doPlay() for specific behaviour

This extends from the template method:
 - put every virtual method inside a template method


------------------------------------------Maps--------------------------------------------
"Hope these help you to navigate through the DD life"

map<string, int> m;
m["abc"] = 1;
m["def"] = 4;

cout << m["ghi"] << endl; // wont crash, will only print 0
// the rule is that if the key is not present, it is inserted and the value is default
// constructed. For ints that mean 0
cout << m["abc"] << endl; // prints 1

to delete
m.erase("abc");

To check if something is present in the map
if (m.count("def")) // will return 0=notFound, 1=Found
// there is also multimap where things can occur more than once.. 
