-------------------Pattern matching in text files-------------------

egrep (extended global regular expression print)

Usecase: egrep pattern file - prints every line in the file that is matching the pattern

eg: print every line in the file index.html that contains cs246 
--> egrep cs246 index.html // pattern = cs246

how many lines in index.html contain cs 246?
--> egrep "cs246|cs 246" index.html | wc -l 
// find the pattern, then pipe output of egrep to wc 
// (-l gives the number of lines) to get number of occurences

OR 

--> egrep '(cs|CS) 246' index.html | wc -l 
// allows to search for both “cs246” and “cs246”

available patterns called regular expressions, different from globbing patterns

"[cC][sS] 246" [] means to look for any one char between [ and ] 
               [^...] means to look for any one character except ... 

Now try adding an optional space: 
"[cC][sS] ?246" 
	? = 0 or 1 or preceding expressions // so we are looking for:
		“cs(0 or 1 space characters)246”
	
Now what if you want to leave multiple spaces?
	* = 0 or more of preceding  spaces. notice that its different from globbing
“cs( )*246” // we are looking for “cs(0 or more space character)246”

Similar example: 
"(cs)*246" // we are looking for “(0 or more occurences of “cs”)246”
Possible results -> 246, cs246, cscs246, 

Next regular expression is a . (dot) matches any single character
	.* then means anything at all 
// we are saying 0 or more occurances of any character, which imples, find everything 

"cs.*246"
Possible results -> lines containing cs(anything in between)246

Always remember that egrep gives you lines that contain the pattern, not number of occurences

More regular expressions

^,$ - beginning and end of a line. //begin matching exactly with the characters after ^(chars)
// match line that ends with character before (chars)$

"^cs246" // lines that start with cs246

"^cs246$" // lines that are exactly like cs246

last regular expression is:
.+ // 1 or more ocurences of preceding pattern

.+ gives you anything non-empty // looking for any one character occuring atleast 	once. Means we are looking for non-empty

eg: We are looking for lines of even length

(..)* this gives you even lines, but 0 is even too. so you have to fix it with "^(..)*$" which means that it will have atleast 2 in length.
	// the two dots in brackets mean any two characters, so its either 2,4,6..

List files in current directory with names containing exatly one a 

ls | egrep "^[^a]*a[^a]*$" // start with 0 or more occurences of not a
	// then look for 0 or more occurences of a with no a after it

Look for all words in the global dictionary that start with e and have 5 characters 

egrep "^e....$" /usr/share/dict/words // starts with e and .... means any 4 other 	characters after e

-------------------------------Permissions-------------------------------

	new flag for “ls” command. ls -l gives the long form listing

eg:
-rw-r----- 1 j2smith j2smith 25 Sep 9 15:37 abc.txt

Char 1:
type - what kind of file is it.
	// - an ordinary file. 
	// d is a directory 

Next 9 characters are permissions, 3 groups of 3 bits 
	1st 3 are user bit (file owner)
	2nd 3 are group bits 
	3rd 3 are the other bits (for all other people)
they tell you what each class of user can do to a file or directory

Next we have # of links:
	owner - user that owns the file
	groups - grops is how linux allows file sharing. a user can belong to 1+ 				groups 
             - a single file can be associated with one group

Then we have:
	size - file size in bytes
	last modified - last modified timestamp
	name - filename

Q: What would happen if you are inside a directory where you have r bit disabled? 
A: its like being in a dark room. if you know what is in the directory, you can get 	to it, if you dont, you can only try guessing

A: On the other hand, if the directory bit is not set it is like a brick wall.
Means that you have no acces to the directory nor to any file or subdirectory.

Now consider changing permissions 

command: chmod [mode] [file] 
// mode is u for user
	     g for group
	     o for other
	     a for all,
		 
// + to add permission
   - to remove permission
   = to set permission
 
eg: if you want to give everyone permission to read file
--> chmod o+r [file]

if you want to make everyones permission read and execute 
--> chmod a=rx [file] // need equal because someone might already have write permission and you want to take that away from them

what if you want to give a user full control? 
--> chmod u=rwx [file] // or u+rwx file
// file/directory owner can always change the permissions so can root


-----------------------------Shell scripts-------------------------------------
	// files containing sequences of shell commands executed as programs

eg: we want to print date, current user, current dir
#!/bin/bash // this is called “shebang line” needed to tell bash where to look for 		// our code
date
whoami
pwd

to execute, you have to type ./myscript in command line 
// here we are saying that bash should look in ./  (current) directory for script

since we are talking about programming, you can set variables here too:

eg: x=1 
// in variable declaration, no spaces are allowed. Because then, the shell will think that you are running a command called 'x', with args “=” and “1”)

Now getting value of a variable:
eg:
echo x
// will not work, because it will simply return 'x', you have to use something to tell echo to fetch the x value

Instead, we should use:
eg:
echo $x

Notes:
* Use $ when fetching the value of a variable, No dollar sign when setting a variable tho.		 
* Good practice: ${x} might change things occasionaly when you dont know where the variable name ends. For example ${file}.in is different from $file.in
* Finally, all shell varibales are Strings

eg: 
dir=~/cs246
echo ${dir}

Output:
/u3/username/cs246
	
There are also come global variables that are always available to you:
eg:
${PATH} // a list of dirs separated by colons. 

Reason why shell could't find your script earlier (when you run without “./”)is because it has a set list of directories to look for programs that you are trying to run.
When you type a command, shell searches these directories in order to find a program with that name

There is a difference here too:
	* echo "$PATH" --> expands // “” returns value of $PATH
	* echo '$PATH' --> doesn't expand // '' returns var name PATH

Special variables for Scripts:
	$1, $2, $3 .... $n 
// these values represent command line argumens that you pass to your script
	
eg: Check wether a word is in the dictionary (./isitaword hello)
	#/!bin/bash
	egrep "^$1$" /usr/share/dict/words
	
eg: a good password should not be found in a dictionary. check whether a word is a good password
	#!/bin/bash
	egrep "^$1$" /usr/share/dict/words > /dev/null 
// now we don't want egrep to print anything, so we redirect output to /dev/null. It's like a black hole where you can redirect all the output to dismiss it

// Note: every program returns a status code, when finished. In case of egrep, the status codes are 0 if found 1+ matches and 1 if not found. (And thats a general convention: 0 = success, !0 = failure)
							   
// Usually, 1 is an expected failure, and larger numbers represent more serious failures

“$?” is the status of the most resently executed command

Now, if statements:

if [ $? -eq 0 ]; then 

// Be very careful with spacing. What it does is runs a command and checks for 	success.
// “[“ is the name of a program and other things are the arguments. 
// “;” is needed to separate commands, otherwise you'd have to put “then” on the 	next line

	echo “Bad Password”
	else
	echo “Maybe a good password”
fi

eg: now we want to be more careful about the input and verify arguments. Print error messge if something is wrong

#!/bin/bash
usage () {
	echo "Usage: $0 password" >&2 
	// “$0” is the command itself “>&2” means redirection of output to the stderr
	}
	if [ $# -ne 1 ]; then // $# - number of arguments
	    usage // calling function usage()
	    exit 1 // exit with expected error
	fi // closing if statement
	.... as before ....

In general, the if statemnt looks like this:
	if [ cond ]; then
		-
		-
		-
	elif [ cond ]; then // many more conditions are available on the handout
		-
		-
		-
	else 
		-
		-
		-
	fi 

------------------------------Loops------------------------
	
	WHILE LOOP:
eg: print numbers from 1 to $1
    #!/bin/bash
    x=1
    while [ $x -le $1 ]; do
    echo $x
    x=$((x+1)) // this wont work x=$x+1, because $x is a string and you will get "1+1"
    done

Though, most of the time we are going to be looping over a list of files, so we need a different kind of loop
	
	FOR LOOP:
eg: you want to remame all .cpp files in pwd to .cc
    #!/bin/bash
    for name in *.cpp; do // *.cpp is a glob that finds all matching files
    mv ${name} ${name%cpp}cc // "${name%cpp}" is the value of name without the trailing cpp
    done
		
eg: how many times does the word $1 appear in the file $2
    #!/bin/bash
    x=0
    for word in $(cat $2); do
    if [ "$word" = "$1" ]; then // because we are not comparing strings, we are using =, for numbers use -eq
	x=$((x+1))
	fi
    done
	echo ${x}
	
eg: Payday is the last friday of the month. When is this month's payday?
    2 tasks: compute date, report answer
	#!/bin/bash
	answer () {
	  if [ $1 -eq 31 ]; then // inside a function $1, $2 ... $n are the arguments of a function
	  echo "This month: the 31st"
	  else
	  echo "This month: the ${1}th"
	  fi
    }
	answer $(cal | egrep "[0-9]" | awk '{print $6}' | tail -1)  
	    
Generalize to any month, but if you dont give a specific month to the program, it will work the old way
	#!/bin/bash
	answer () { 
	  if [ $2 ]; then 
      	preamble = $2
      else
      	preamble = "This month"
      fi

	  if [ $1 -eq 31 ];
      	echo "${preamble} the 31st"
      else
      	echo "${preamble}: the ${1}th"
      fi
    }
	answer $(cal $1 $2 | awk '{print $6}' | egrep "[0-9]" | tail -1) $1 // $1 is the month, if there is no month and a year, then $1 and $2 are blank, nad we get the old behaviour

---------------------------Testing--------------------------
	essential part of program development
	
Machine testing
	- run program on selected input check against spec
	- can't always check everything, so you have to check your test cases carefully

Black box - tester has no knowledge or access to the internal workings of a program
Grey box - tester has limited knowledge of the internal details of the program
White box - tester uses program's source code as basis for designing tests
	
So we always start with black box, and then add white box tests 

Various classes of input
	- numeric inputs
	- positive vs negative
Boundaries of valid ranges (very important)
	- edge cases
	- multiple edge cases silmuntaneous (corner cases) 
Intuition/Experience will allow for better tests, because you will have understanding of where code usually breaks
Extreme cases (maximum difficult variables)
White box tests - execute all logical paths through the program (Coverage)
	- make sure all your functions get called atleast once
	- make sureevery single line of your code has been used
Performance testing - is the program efficient enough?
Regression testing - sometimes you fix one thing, but then break something else. Have to look out for those
	- thats why we use test suites, testing scripts, this way we can keep adding tests until we cover everything


----------------------C++--------------------------
	We will learn c++14

	Start with what we know, so in C
	
Hello World in C:
	
#include <stdio.h>
int main() {
  printf("Hello World\n");
}

Hello World in C++
	
#include <iostream> // stdio.h printf is still available here, but preffered to use header <iostream>
using namespace std; // lets you say cout/endl instead of std::cout/std::endl			   	

int main() { // main must return int in C++
  cout <<"Hello World"<<endl;
  return 0; // this is a very good practice to return something at the end. Technically we do say that main() returns int.
}

How to compile C++ programs?
-> g++-5 -std=c++14 program/cc -o program // "-o program" name of created executable, by default: a.out

Since we did aliases to out profile in a0, we can write compilation command in a much shorter form:
-> g++14 program.cc -o program
and to run your program, type: 
-> ./program

printf and other c code is banned in this course, always use c++ functions, methods, expressions, etc..

-----------C++ I/O streams-----------------

C++ gives you 3 i/o streams
	- cin for reading from stdin
	- cout, cerr for printing to stdout and stderr

I/O operators: 
	<< means "put to" for output
	>> means "get from" for input

So you can do code like this: 
	cerr << x; - information is flowing from x to cerr
	cin >> x; - information is flowing from cin to x 

Arrows show where the information is flowing and its direction

eg: add two numbers

#include <iostream>
using namespace std;

int main() {
  int x, y;
  cin >> x >> y;
  cout << x + y << endl;
  return 0;
}

cin operator ignores whitespace 
 - if input doesn't contain numbers, cin fails and var is undefined
 - if input is exhausted before we give 2 ints, we press ^d (EOF) then the statement fails and var is again undefined
 - if read fails, there is an expression cin.fail() which will always be true when read fails
 - if you get EOF, then cin.eof() and cin.fail() will both be true // However, these won't turn on, until you try to read file and fail

eg: read all ints from stdin, echo them one per line to stdout, stop on any failure

*********v1.0 of example***************
int main() {
  int i;
  while (true) {
  cin >> i;

  if (cin.fail()) break;

  cout << i << endl;
  }
}

there is an "implicit conversion" (remember this word) from cin or cout to bool, which means you can use cin as a condition
 - so cin is true if successful and false if failed

********v2.0 of example*********** 
int main() { 
  int i;
  while (true) { 
    cin >> i;

    if (!cin) break;

    cout << i << endl;
  }
}

Now a little bit more details about >> << operators
 - >> this is C's right bitshift operator. a >> b shifts a's bits to the right y b spots

eg: 
	21 >> 3 
	we know that 21 = 10101 
	So 21 >> 3 = 01 >> 11 = 10
this means the same in C++, cin moves a bits to b, hence "get from"

operator >> : 
 - has inputs cin on the left (istream) and data on the right (variety of inputs)
 - output? - returns another cin (istream)
 - this is why you can write cin >> x >> y >> z; 

*********v3.0 of example **************
int main() { 
  int i;
  while (true) {
  if (!(cin >> i)) break;
  cout << i << endl;
  }
}
  

********v4.0 of example ***********
int main() { 
  int i;
  while (cin >> i) { 
    cout << i << endl;
  }
}

eg: read ints and echo to stdout until eof, skip all non-int input

int main() {
  int i;
  while (true) {
	if (!(cin >> i)) {
	  if (cin.eof()) break;
	  cin.clear(); // clears the fail bit. But the wrong character is still in the stdin.
	  cin.ignore(); // means to skip the next character
	}
	else cout << i << endl;
  }
}

------------------------Reading Strings------------------------

c++ has a type std::string, which you get by #include <string>

int main() {
  string s;
  cin >> s; // skip leading whitespaces and stop at the next whitespace (reads one word)
  cout << s << endl
}

if you do actually want to read the whitespaces, use: getline(cin, s)
 - reads form current position to new line into s

Examples:
	cout << 95 << endl; // will print 95 to the screen now if you want to show the value in hexadecimal.
	In C you have to use %x with printf, but there is no printf in c++

So we use this instead:
	cout << hex << 95 << endl; // prints 5f, which is 95 in hexadecimal
	hex - is an io manipulator. It works in a way, that from now on, all subsequent ints are printed in hex
	
if you want to print only one in hex, use "dec" to go back to decimal. (There are many manipulators that are available to us. You can find those in the printed notes)
	many of the manipulators will require to use #include <iomanip>

Stream abstraction applies to other sources of data. For example, files
 - You may want to read from a file, rather than stdin
 - std::ifstream - read from a file
 - std::ofstream - write to a file
	
-----------------------File access in C----------------------------

int main () {
 char s [256];
 FILE *file = fopen ("myfile.txt", "r");
	
 while (true) {
    fscanf(file, "%255s", s);
	if (feof(file)) break;
	printf ("%s\n", s)
  }
  fclose(file); // awlays have to close the file
}


----------------------Now file access in C++------------------------

#include <iostream>
#include <fstream>
#include <string>
using namespace std;

int main() {
  ifstream file {"myfile.txt"}; // stuff in the curly brackets is initialization syntax. Declaring the ifstream, opens the file.
  // We will see this notation later again
  string s; // string is now a type and they manage their own size, not like C

  while (file >> s) { // this will only read a word at a time, use getline(file, s) to read a line
	count << s << endl;
  }
// no fclose(), the file is closed automatically, as soon as ifstream goes out of scope
}

Anything you can do with cin and cout, you can also do with an ifstream and ofstream

Example:
 - strings: attach stream to a string variable and read from/write to it
 - the include for stream string is #include <sstream>
 - types are std::ostringstream, std:istringstream 

Imagine you have two ints lo=xxxx, hi=yyyy and you want to use them to print a string:
	ostringstream ss; // create a string stream variable
	ss << Enter a # between " << lo << "and" << hi; // you first fill in the stream
	string s = ss.str(); // then you turn the stream into a string

eg: Convert string into #
int main() {
  int n;

  while (true) {
	cout << "Enter a # " << endl
	string s;
	cin >> s;
	
	istringstram ss {s}; // stuff in {} is initialization
	// you first read in a string, then turn it into a stream

	if (ss >> n) break; // check if you got an integer out of the stream
	
	cout << "I said, "; // if no ints, keep reading
  }
  cout << "You entered " << n << endl;	
}

EXAMPLE revisited: read in #s, skip non-ints

int main() {
  string s;
  int n;

  while (cin >> s) { // the only way reading a string can fail, is if you have EOF
	istringstram ss {s}; // you put the input into a string stream
	if (ss >> n) cout << n << endl; // then you try to get out an int from the stream
  }	
}

Behaviour is slightly differnt tho, try printing "a1s2d3f4" with both functions

--------------------------Strings------------------------

in C strings are char* or char[] terminated by \0
 - you must explicitly manage memory
 - you must allocate more, as strings get larger
 - very easy to overwrite that trailing "\0" and corrupt your memory

in C++ strings
 - grow as needed, no need to manage memory
 - safer to manipulate, because they don't depend on the "\0"

eg (Very important to understand):
	
string s = "hello"; // "hello" is still a C style string with chars |h|e|l|l|o| 
// s is a C++ string created from C string upon initialization
// this is needed for the backwards compatibility with C
// this works because of implicit type conversion

C++ String operations:	
 - Equality: s1 == s2, s1 != s2
 - Comparison: s1 <= s2 (lexicographic)
 - Get invidual characters: s[0], s[1] ... s[n]
 - Concat: s3=s1+s2; s3+=s4;
 - Length: s.length()

* more details are in the printed notes

		Default function parameters:

void printWordInFile (string name="suite.txt") { // passing a default parameter 
  // name can be passed when we call function, but it is not passed, a default value is used
  ifstream file {name};
  string s;
  while (file >> s) cout << s << endl;
}

Now you can call: 
printWordsInFile("test.txt")
Or say printWordsInFile() // and it will use default value
IMPORTANT: optional parameters must always come last 
	 imagine you have a f(int k=5, int n) // if you call f(5) the compiler won't know wif n is 5 or if k is 5


		Overloading:
c: 
int negInt(int n) {return -n;}
bool negBool(bool b) {return !b;} 

c++: Functions with different parameter names, can share the same name
int neg(int n) {return -n;}
bool neg(bool b) {return !b;}

The act of doing this, is called overloading. 
	Now when you call a function by its name, how does the compiler know which one, you meant?
	 - compiler, uses the number and type of the arguments to decide which name is being called. So overload must differ in # of args or types of args
	 - may not simply have different return types

------------------Structs----------------------
	
struct Node {
  int data;
  Node *next; // in c++ you dont have to mention that Node is a struct
};

struct Node {
  int data;
  Node next; // what is wrong with this? -> We have a node inside of a node. You would not be able to tell the size of this stucture
};

-------------------------Constants------------------------
Constants: const int maxGrade = 100; //must be initialized, you should be using it as much as you can
	
Node n1 = {5, nullptr}; // sytax for null pointer. Null is not a built in variable in c or c++
// null usually is a number = 0, But that could be a problem because you want to use a null for a pointer and it will give you a number, not a pointer
// thats why c++ came up with nullptr so that you dont have to use null for pointers
	
const Node n2 = n1; // this is an immutable copy of n1, means that you can't change n2's fields

----------------------Parameter Passing------------------

Recall the following from 136: 
void inc (int n) {++n;}
...
int x = 5;
inc(x);
cout << x << endl; // still prints 5
// example of call by value, where inc() gets a copy of x, increments the copy and the original is unchanged.
	
// if you would like to inc to be able to modify the x, you want to pass the pointer to the value, rather than a copy
void inc (int *n) {(*n)++;}
...
int x = 5;
inc(&x); // using x's address, rather than the value
cout << x << endl; // prints 6 	 

Q: Why do we say cin >> x and not cin >> &x?
A: C++ has another pointer like type, they are called references

-------------------------References-------------------------- 
					(VERY IMPORTANT)

	int y = 10;
	int &z = y; // im saying, z is an lvalue reference to y
				// like a const pointer, similar to a declaration like:
				// int *const z = &y (not exactly the same tho)

	References are like constant pointers with automatic dereferencing
	
	z[]---->y[10] // z is pointing to the memory location of y and can't be changed

	z = 10; (not *z=10;) // and we get that y == 10

	int *p = &z; // trying to take the address of z, but when you do it, it gives you the address of y
				 // so in all cases z behaves exactly like y, they really should be indistinguishable

	we can say z is an alias ("another name") for y
	
	Rules for referencing: "Things you cant do with lvalue references" 
	1. Can not leave them uninitialized //eg: int &x;
	2. Must initialize to something that has an address // "something that has an address" is called lvalue - the thing on the left of the assignement value
		// eg: int &x = 3; bad
		// eg: int &x = y + z; bad 
		// eg: &x = y; good
	3. Cannot create a pointer to a reference: int &*x; bad // always start with the variable and work your way up
		But, perfectly legal to create reference to a pointer: int *&x= ____; good
	4. Cannot create a reference to a reference:
		int &&x=___; // this means something different (covered later)
	5. Cannot create arrays of references: 
		int &r[3]= {n,n,n}; bad

	Rules: "Things you can do"
	1. Pass references as function parameters. 
		void inc (int &n) {++n;} // &n is a constant pointer to the argument. 
								 // Notice: no pointer dereference, and printing passed value later will give you incremented value

	Q: So why does cin >> x works? 
	A: Because the operator that you are using takes x by reference

	Now we can discuss the exact signature of an input operator:
	istream &operator>> (istream &in, int &data) // why use references? because rather than using call by value, where you take a copy. It is not allowed to copy streams, 
												  // also means you can't pass it by value, can only pass by reference	
	Pass by value. eg: int f (int n) {...} // copies the argument
	-- If the file is very large, then the copy can be expensive 
	
	eg: struct ReallyBig {....}; // if you create a pass by value function on that.
		int f (ReallyBig rb) {...}; // to avoid copying, you can pass it by reference
		int g (ReallyBig &rg) {....}; // since i didn't do any copying, this thing is fast
	"Downside: i can no longer guarantee that rb won't change".
	
	So the question is can you have the best of both worlds, where its fast and won't change? Yes!

	int h (const ReallyBig &rb) {...}; // this way its still fast (no copying) and the parameter cannot change. 
	"Only downside left is if you actually wanted to change rb inside the function, but not outside"
	So here is the advice: 
	Prefer to pass-by-const-ref over pass-by-value for anything larger than a pointer. Unless the function needs to make a copy anyway - then maybe pass by value. 
	
	**** 1 More example ****

	int f(int &n) {....};
	int g(const int &n) {...}; 
	
	f(5); // this won't compile
	// because 5 doesn't have an address. Can't initialize an lvalue reference to a literal value.
	// if n changes, can't change the literal 5 because reference is not pointing to a memory
	
	g(5); // perfectly legal
	// because its a constant reference. Since n can never be changed, the compiler allows this.
	// how? - compiler creates a temp location to hold the 5, so ref n has something to point to. 

--------------Dynamic Memory Allocation----------------
	In C, we used to do this: 
	int *p = malloc(_______*sizeof (int));
	....
	free(p);
	"DONT USE THIS IN 246"
	
	Instead, use new/delete, which is better because its:
	-- type aware
	-- less error prone
	
	EXAMPLE TIME!!
	struct Node {
		int data;
		Node *next;
	};
	When this runs, lets look at the stack and the heap:

	Stack:
	------
	np // points to values that are on the heap

	Heap:
	------
	data
	next

	Create a new value on the Heap
	Node *np = new Node;
	....
	delete np;
	
	All local variables are stored on the stack, varaibles are deallocated once they go out of scope. (stack is popped)
	Allocated memory is stored on the heap, it remains there until (delete is called)
	If you don't delete all allocated memory, you will have a memory leak. Program will eventually fail - incorrect behaviour

	Note: before we asked for space to store only one node
	But we sometimes want to store more things, so we do this:	
		Node *np = new Node[10]; // allocates space for 10 nodes. 
		....
		delete [] (np);

--------------------Return-by-value----------------------
	
	eg: 
	Node getMeANode() {
		Node n;
		return n;
	} // maybe the best option because you might want to take a risk of extra memory use but not have to worry about clearing memory

 	Creating a node and giving it back to the user, requires making a copy. Could be expensive!
	
	Q: How to avoid that copy? 
	A: Return by pointer(ref) instead. 

	Node *getMeANode() {
		Node n;
		return &n;
	} // one of the worst things you can do

	IT RETURNS A POINTER OR A REFERENCE TO A STACK-ALLOCATED DATA THAT IS DEAD ON RETURN.
	// out of scope!!!
	// problem that you will not actually crash a program right away and compiler might not tell you what the problem is

	If you want to return something fast, make sure the thing you are returning is not from the stack
	Node *getMeANode() {
		return new Node; // new allocates space on the HEAP
	} // this works, but you gotta remember that there is something on the heap and you have to delete it at some point	
	
----------------------Operator overloading--------------------

	(this is amazing, changed my life #revolutionary)

	Operator overloading allows us to give meanings to C++ operators for our own types
	eg:
	struct Vec {
		int x, y;
	};

	Vec operator+ (const Vec &v1, const Vec &v2){
		Vec v={v1.x+v2.x, v1.y+v2.y};
		return v;
	}

	Vec operator* (const int k, const Vec &v) {
		return {k*v.x, k*v.y}; // ok because the computer knows that its a Vec based on the return type
	}
	
	Vec operator* (const Vec &v, const int k) {
		return k*v;
	}; 

---------------Overloading << and >> (I/O operators)-------------------

	eg:
	struct Grade {
		int theGrade;
	};


	ostream &operator<< (ostream &out, const Grade &g) { // you have to use references because ostream can not be copied
		out << g.theGrade << '%' // to print a percent sign every time after the grade
		return out; // or "return out << g.theGrade << '%'"
		// key is that we have to return ostream, just like cout does
		// this way we can use cascading effect: cout << x << y << z << endl;
	};

	istream &operator>> (istream &in, Grade &g) { // no const for Grade because you want to change it
		in >> g.theGrade;
		if (g.theGrade < 0) {
			g.thegrade = 0;		
		} 
		if (g.theGrade > 100) { 
			g.theGrade = 100;
		}
		return in; // have to return istream because of the cascading effect
	}
	
	int main () {
		Grade g;
		while (cin >> g) cout << g << endl;
	}

--------------------------The Preprocessor------------------------

	Transforms the program before the compiler sees it. 
	// you know you are dealing with a preprocessor because you will see a line like this: 
	// #_______ - preprocessor directive 
	We already know the #include
		- if you are including old C headers, there is a new naming convention:
		eg: instead of #include <stdio.h> use #include <cstdio>

	#define VAR VALUE // sets a preprocessor variable.
	// acts like search and replace. If preprocessor ever sees a VAR anywhere, it will replace it with VALUE

	#define MAX 10 
	int x[MAX]; // transformed int x[10] a way to create constant variables
	This is very outdated tho, we use const definition instead
	Then why are we covering it? --> It can be used for other things 
	
	#define FLAG // sets the variable FLAG and its value is the empty string
	So once you compile the code, all isntances of FLAG will be gone.

	This is also useful for conditional compilation. Sometimes you want your program to look different in different situations. 
	In order to accomodate for different OSs, you have to vary code a little bit.

	eg:
	#define IOS 1
	#define BBOS 2
	#define OS IOS (or BBOS)
	#if OS == IOS
		short int publickey; // if true, compiler sees this
	#elif OS == BBOS
		long long int publickey; // if false, this code is suppressed and compiler doesn't see it 
	#endif 
	Remember that preprocessor runs before the compiler sees it. 
	
	Special Case:
	#if 0 // this is never true, all inner text is removed before it gets to the compiler
	#endif 
	Good as a heavy duty commenting out

	Can also define symbols via compiler arguments
	eg: 
	int main() {
		cout << X << endl; // won't compile, because x is undefined
	}
	
	But we can define x on the g++ command line
	--> g++ -DX=15 define.cc -o define // this use capitals for all defined variables
	
	#ifdef NAME // true if NAME has been defined
	#ifndef NAME // true if NAME has not been defined

	Useful for debugging
	eg:
	int main() {
		#ifdef DEBUG
			cout << "setting x=1" << endl;
		#endif
			int x=1;
			while (x < 10) {
				++x;
				#ifdef DEBUG
					cout << "x is now" << x << endl;
				#endif
			}
		cout << x << endl;
	}	

	if you compile it normally
	--> g++14 debug.cc -o debug
	if you want to debug 
	--> g++14 -DDEBUG debug.cc -o debug

	
-----------------Separate Compilation-------------------

	You want to split your program into composable modules, with an 
	- interface: contains things such as type definitions, prototypes of functions (your .h file)
	- implementation: the full definition of your functions (your .cc file)

	Recall: 
		when we speak of a declaration, all it does is it asserts existance, whereas definitions give full details and allocate space
		for those things that occupy space. 

	eg: if we take the Matrix functions from before and make them into proper files
	**************vec.h*************************
	____________________________________________
	struct Vec {
		int x, y;
	}

	Vec operator+ (const Vec &v1, const Vec &v2);


	*************main.cc************************
	____________________________________________
	#include "vec.h"
	
	int main() {
		Vec v = {1, 2};
		v = v + v;
		.....
	}


	*****************vec.cc*********************
	____________________________________________
	#include "vec.h"
	
	Vec operator+ (const Vec &v1, const Vec &v2) {
		....
		....
		....
	}

	Recall, an entity can be defined many times, but defined at most once.

-----------------Linker (Compiling separately)------------------------
	
	VERY IMPORTANT:
		ls the directory:
			vector.h vector.cc main.cc
		then you run:		
			g++14 vector.cc
		and get a bad error:	// if you get errors in /usr/bin/ld then you are fine, its a linking error
			look at the pre-last line: thats where the error is
		then you run:
			g++14 main.cc
		and get a bad error again // look at the end for error description again
		

	To compile separately, do:
	-> g++14 -c vector.cc
	-> g++14 -c main.cc
	// -c means compile only, do not link, do not build the executable
	So now we have a compiled, but unlinked code: 
		ls the directory:
		main.cc main.o vector.cc vector.o vector.h

	.o file is an object file all compiled, but not liked. 
	To do linking, use 
		g++14 vec.o main.o -o main
	now you can run ./main

	Notice, we didn't compile .h file. 

	NOTICE!!!!
	NEVER EVER, EVER COMPILE .H FILES EVER!!!!
	!!!!!!!!!code in the .h files is compiled automatically because it is included in other files

	Suppose you wanted to add a global variable 
		Global var: int globalNum;
	You should never include it in the .h file because every time the .h file is included compiler will make a copy of it
	You have to define it in .h, but not initialize it using extern global var;
	Initialize the variable in a .cc file global var = 14;

------------------------Including things in your modules---------------------------

	imagine you have vec.h, vec.cc, linalg.h, linalg.cc, main.cc
		!!!!!!this won't compile!!!!!!!!! 
	main.cc, linalg.cc include linalg.h, vec.h
	linalg.h includes vec.h

	-> main.cc, linalg.cc get 2 copies of vec.h

	STRUCT VEC IS DEFINED TWICE 

	Need to prevent files from being included

	Solution: 
	Vec.h:
	#ifndef VEC_H
	#define VEC_H
	.
	. // file content
	.
	#endif

	First time vec.h is included symbol VEC_H is not defined, so file is included. After that VEC_H is defined, the contents are suppressed

	Rules: 
	- ALWAYS put include guards in .h files 
	- NEVER include .cc files // you will end up with 2 copies of definitions and functions because you will get one from .cc file and another when .cc is included somewhere else
	- NEVER put using namespace std in header files // if you do that, you are forcing your client not to use std namespace either, which is not fair
		- inside header files always say std::cin, std::string etc.

	Midterm coming up
	-> Better study, do not be behind on aynthing! gotta understand week 1 content

-----------------------------------------OOP Classes------------------------------
	- is different from structs because you can put functions inside of classes
	
	eg:
	struct Student {
		int assns, midterm, final;
		float grade () {
			return assns*0.4 + midterm*0.2 + final*0.4;
		}
	}

	Student s{60, 70, 80} // then you can create a struct 
	cout << s.grade() << endl // and use functions inside classes to return values

	Definitions: 
	- Class -> a struct type that can contain functions
			-> c++ does have a class keyword. We will cover it later

	- Object -> an instance of a class
			 -> So Student s{60,70,80}. Student is the class and s is the object
			 -> then function grade(), is called a member function or a method. First method that we have written in this course, before this, everything was functions.

	What do assns, midterm, final inside of grade() {.....} mean? What do they refer to, if in struct we didn't initialize anything?
		-> They are fields of the current object // upon which grade was invoked.

	eg: 
	Student billy{60, 70, 80}
	billiy.grade() // This is a method call and inside the grade(), billy's assns, mitderm, final are used.

	This is why methods and functions are different
		Formally: methods takes a hidden extra parameter called "this"
		- this is a pointer to the object on which the medhod was invoked
		eg: billy.grade() // this == &billy

		can write the following to be more formal:
		Struct Student {
			int assns, midterm, final;
			float grade() {
				return this->assns*0.4+this->midterm*0.2+this->final*0.4;
			}
		}

------------------Object Initialization----------------------

	Student billy{60, 70, 80} // ok, but a bit limited

	A better option would be writing a method that does the initialization for us
		- such a method is called a constructor

	Struct Student {
		int assns, midterm, final;
		float grade()  {........}
		
		Student(int assns, int midterm, int final) {
			this->assns=assns;
			this->midterm=midterm;
			this->final=final;
		}
	}

	Now that we have a constructor, we can do this:
		Student billy{60,70,80}; // this is much better

	DIFFERENCE: now we are calling our own constructor
	It works like this: if a constructor has been defined, the three variables are being passed to contructor,
						if no constructor has been defined, these initalize the individual fields of student.

	OR // a different syntax, but does the same thing
	Student billy = Student{60,70,80};

	before we were creating billy object on the stack. Now to create it on the HEAP:
	Student *pBilly = new Student{60,70,80};

	Advantages of constructors:
	- default parameters
	- overloading
	- sanity checks (validate values) 
		
	eg:
		Struct Student {
			....
			Student (int assns=0, int midterm=0, int final=0) {
				....			
			}
		}

		Now we can do Student Jane{60, 70} // where final is initialized as 0
		Student newKid; // all the marks are 0

	Note:
		- Every class comes with a default constructor (takes no arguments)
	eg: 
		vec v; // something we did a couple days ago. 
			   // this calls a default constructor. What it does is it runs through struct and default-constructs any fields that are objects
			   // in case of vec, it does nothing because there are no objects, all we had are the two ints, which are not considered as objects

	So if it does not do anything, how do you know that it's there?
	-> You can check by taking away the dafault constructor

	The built-in default constructor GOES AWAY if you provide your own costructor
	eg:
	Struct vec {
		int x, y;
		vec(int x, int y) {
			this->x=x;
			this->y=y;
		}
	};

	Now if we run vec v, it won't compile. It compiled before, but it won't anymore, because the default constructor has been overwritten by our own constructor
	// However, before, when we intialized structures the x and y were both uninitialized
	// Remember how we mentioned that default contructor only initializes objects?
	// What happens is that our default constructor, calls the other object's default contructor.. and so on

	What if a struct contains const or refs?
	Struct myStruct {
		const int myConst;
		int &myRef;
	} // this is interesting, because const and ref, must be initialized 
	 
	int z;
	Struct myStruct {
		const int myConst=5;
		int &myRef=z;
	} // we can do this, but its probably not what we want
	// because at the end we will end up with as many myCosnt as objects that we created. We will have way too many duplicates

	But does every instance of myStudent need the same value of myConst?
	eg:
	Struct myStudent {
		const int id; // doesn't change, but you don't need the same one for all students
		...
	}

	So if that is not what we need. How should we do it then?
	// by the time it gets to constructor body, it will be too late, because the fields should have been intialized before that

	What happens when an object is created? 
	1) Space is allocated
	2) Fields are constructed // we want to put our intializations here!!!
	3) Constructor body runs // its too late to intialize variables here because they happen in step 2

	We do that using MEMBER INITIALIZATION LIST (MIL)
	eg:
	Struct Student {
		const int id;
		int assns, midterm, final;
		Struct (int id, int midterm, int final):id{id}, assns{assns}, midterm{midterm}, final{final} { // before we start the construction body, right before the first "{"
			// there are rules tho. stuff before the curly brackets are fileds. Inside the brace brackets are the normal c++ scope rules and id, assns, midterm, final are just parameters
		}
	}

	Notes: 
	- Notice that you can intialize any field this way, not only const and ref
	- The fields are initialized in which they are declared in the class, not in order of MIL. // so that if one field uses a value of another, it still works
	- MIL is sometimes more efficient then setting fields in the body // because no matter what you do, step 2 is going to happen
		eg: you have a String name in your class. if you dont intialize String in your step 2, it will still happen because objects are always intialized in default constructor
			so you will do the work twice, to first initialize string as null and then to give it an actual value
	MORAL!!! embrace the MIL. You should be using it all the time in constructors
	
	What if a field is initialized inline, and in the MIL?

	Struct vec {
		int x=0, y=0;
		vec(int x): x{x} {
			....
		}
	} // MIL takes precedence over regular field initializations
	  // Basically overrides them with its own values 


--------------------Uniform Initialization--------------------------
	
Old ways to initialize:

	int x = 5;
	string s = "hello";
	
	OR

	int x(5);
	string s("hello");
	Student billy(60, 70, 80);

New Preferred method:

	int x{5};
	string s{"hello"};
	Student bily{60,70,80};

Now consider:

	Student billy{60,70,80};
	Student bobby = billy; // How does this intialization happen? 
		- the copy constructor 
		- for constructing one object as copy of another
		- so we get a copy constructor for free


Note: Be very careful with constructors that can take ONE parameter !!!!!!!!!!!
	eg:
	Struct Node {
		int data; 
		Node next;
		.....
		Node (int data): data{data}, next{nullptr} {
			......
		}
	};
	This is dangerous because single argument constructors create implicit conversions // Not good, means c++ is changing types behind your back
	Now we can do:
		Node n{4}; // which is totally cool
	but we can also do this:
		Node n = 4; // which means there is an implicit conversion from int to node
	We have already seen this in string hello = "hello"; // where it creates implicit conversion from char array to string
	Now consider this:
		int f (Node n) {.....};
		f(4); // this works for implicitly converted Node
	Danger is:
	- accidentally passing int to a function that is expecting a Node
	- compiler will not signal an error
	Good practice for these scenarios is to disable implicit conversion. To do that, make constructor explicit
	Struct Node {
		...
		explicit Node(int data): data{data}, next{nullptr} {
			.....
		}
	}
	Node n{4}; // is ok
	Node n = 4; // will signal an error
 

	Note: Every class comes with these constructors
 	- default constructor // default construts all fields that are objects
	- copy constructor // just copies all the fields
	- copy assignment operator 
	- destructor
	- move assignment operator

-----------------------------------Copy Operator----------------------------
	if you were to decide to build your own copy constructor, it would look like this:
		Struct Student {
			int assns, midterm, final;
			Student (....) {...} // old stuff
			Student (const Student &other): // you know its a copy constructor because it consumes a structure
			assns {other.assns}, midterm {other.midterm}, final {other.final} {.....}
			// this is exactly what the built in constructor does
		}
		Q: When do you need copy constructors that are different than default one?
		A: Obviously when we are working with linked lists, because that what they do, ruin your life

		Struct Node {
			int data; 
			Node *next;
			Node (int data, Node *next): data{data}, next{next} {.....}
			.....
		}

		Node *n = new Node{1, new Node{2, new Node{3, nullptr}}};

		Understanding memory alloc:
		|_Stack_|__Heap___________________|
		n -----> 1|* --> 2|* --> 3|nullptr

		Node m = *n;
		Node *p = new Node{*n}; // using copy constructor
	
		Understanding memory alloc:
		|_Stack_|__Heap___________________|
		m -> 1|* ----> 2|* --> 3|nullptr
		p -----> 1|* --> 2|* --> 3|nullptr
		// the problem here is that you are not copying, but you are simply pointing to already existing nodes 

		A simple copy of fields => only the first node is copied // known as a shallow copy
		// this is not what you want, most likely your intent was to copy the entire list	

		if you want a DEEP copy // copies the whole list
		Then you have to write your own copy constructor

		eg:
		Struct Node {
			int data; 
			Node *next;
			Node (int data, Node *next): data{data}, next{next} {.....}
			Node (const Node &other): data{other.data}, next{other.next?new Node {*other.next}:nullptr} { 
			// the trick is that when you call "new Node{*other.next}" recurses, so other values are copied too 
				....
			}
			.....
		}

		The copy constructor is called:
		1) when an object initializes another object
		2) when an object is passed by value
		3) when an object is returned by value (*not always - will discuss later)

		Note:
		- can't override copy contructor
		- should always give it values by reference

------------------------------Destructors------------------------------------

	When an object is destroyed:
		- if stack allocated -> goes out of scope
		- if heap allocated -> it is deleted a mathod called the destructor runs

	Every class has a default destructor // it calls destructors on all the object fields, just like the constructor, but the opposite

	Sequence of events that happens when an object is destroyed:
	1) destructor body runs
	2) field's destructors invoked in reverse declaration order
	3) space is deallocated

	Q: When do we need more out of destructor class?
	Node *np = new Node{1, newNode{2, newNode{3, nullptr}}};
	// if np goes out of scope, only the pointer memory is reclaimed (because its on the stack), the list is leaked

	If we say:
	delete np; // this calls *np's destructor, which doesn't do anything 
			   // 1|*-> 2|*-> 3|nullptr. When we run destructor, it kills only objects. 
	So what happens is we delete *np, first node, but the rest of the list is leaked

	Writing a destructor // "~" tilda is what denotes destructor
	Struct Node {
		......
		~Node(){delete next;} // the way that this works is we delete next and call next's destructor, which deletes the next next etc...
		// so this is recursion again
		// we forogot to check for the case of nullptr, but in c++ it is safe to delete nullptr, so we are good to go
	}
	Now: 
	delete np; // deletes the whole list

--------------------------------Copy Assignment--------------------------
	the hardest and trickiest one

	Student billy{60, 70, 80};
	Student jane = billy; // copy constructor
	
	Now consider if we do this:
	Student mary; // default constructor
	mary = billy; // we are copying billy, but we are not constructing mary
	// "=" is an instance of copy-assignment operator. If you don't provide your own, then it will use the compiler's one by default
	// again, the default one might not be good for all the cases, so sometimes we have to write our own
	// Usually, we need to write our own when we work with pointers. We want to avoid SHALLOW copies
	
	Struct Node {
		.......
		Node &operator=(const Node &other) { // notice that the return type has to be a Node
		
		"""
			Aside: in c++ you can do this:
			a = b = c = 4;
			c = 4; -> b = c; -> a = b;
			that's why we need to return Node, so that cascade effect works
		"""	

			data = other.data;
			delete next; 
			next = other.next?new Node{*other.next}: nullptr; // note we are not building a new object, we are using an object that already exists
			return *this;
		} // So apparently this is all wrong and we just spent 10 minutes on this
	}
	Why dangerous?
	Node n{1, new Node{2, new Node{3, new Node}}};
	n = n; // so now we are deleting old data first, but then we try to access deleted data, 
	// which will probably mess up your whole life and you will have to drop out from CS program and go back home and cry a lot, A LOT, A LOOOT.. 
	This gives undefined behaviour
	NOTE: WHEN WRITING OPERATOR = ALWAYS BE AWARE OF SELF ASSIGNMENT

	So the right version:	
	Struct Node {
		.......
		Node &operator=(const Node &other) {
			if (this == &other) return *this; // now if we encounter self-assignment, we will simply return pointer to this

			data = other.data;
			delete next; 
			next = other.next?new Node{*other.next}:nullptr;
			return *this;
		} 
	}

	Now this is apparently an even better version:
	Struct Node {
		.......
		Node &operator= (const Node &other) {
			if (this == &other) return *this; // now if we encounter self-assignment, we will simply return pointer to this
			// now we happpen to know that new doesn't 100% work, that it might fail. And if new fails, this function will bail out because we wont be able to set a value for next
			// and next will keep pointing to old memory, which corrupts the list
			Node *tmp = next;
			next = other.next?new Node{*other.next}:nullptr; 
			data = other.data;
			delete tmp;
			return *this;
		}
	}	
	This is better because if new fails, next and data has not been cahnged yet, so the node is still in valid state
	Also, the actual check for self assignemnt is not necessary here, because we are making a copy of other no matter what, since im working of a copy, 
	it doesn't matter if we are copying form somewhere else or from myself.

	Now there is another version of operator Equal that does everything that the previous version, but is much simpler to write

	#include <utility>

	struct Node {
		...
		...
		...
		void swap (Node &other) {
			using std::swap;
			swap (data, other.data);
			swap (next, other.next);
		}

		Node &operator= (const Node &other) {
			Node tmp=other; //tmp = copy of other
			swap (tmp); // me = copy of other, tmp = my old fields 
			// now since tmp is stack allocated, it is destroyed when this is returned
			return *this;
		}
	}

-------------Rvalues and Rvalue operators-------------------

	recall: an lvalue is anything with an address
			an lvalue reference is like a constant pointer with automatic dereferencing and is aways initialized to lvalue

	Node n {1, new Node{2, nullptr}};
	Node m = n; // copy operator
	Node m2;
	m2 = n; // copy assignment operator

	Node plusOne (Node n) {
		for (Node *p = &n; p; p = p->next) {
			++p->data;
		}
		return n;
	}

	what we get from here is a copy of the original list with every value increased by one

	Now we want to do this:
	Node m3 = plusOne(n); // here we run the copy constructor

	But when we run this, we get 2 calls to the Basic Contructor and 4 calls to the Copy constructor
	- 2 calls to the Basic constructor because of the two nodes that we have
	- the question is why the copy contructor gets called twice (2 on way in, 2 on way out)
	- because there are 2 nodes in the list, it calls itself recursively, so for every node it runs twice

	Now, if plusOne(n) is the other, what is it referencing? 
	- here we are pointing to the temporary object that our compiler created for us, because we actually did not initialize anything
	- so other is a reference to this temporary
		- and the copy constructor deep copies the data from this temporary
	
	But the temporary is going to be discarded anyway, as soon as the statement Node m3 = plusOne(n); is done
	- then why are we copying a temp object if it gets thrown away anyways? 
	- wouldn't it be better if we could steal it instead?
	- it very wasteful to copy from the temp
	  
	Example, one of your friends decided to quit CS246, but they have been taking great notes, whereas you didnt take any. 
	Your friend tells you that you can find the notes in the library, and you like, nah bro if you throw them away, just give it to me.

	The key for this to work is you have to be able to tell, whether other is a reference to a temp or a standalone object
	- up until c++11 this was impossible, but not anymore
	
	Now we rvalue reference Node&& is reference to a temporary object (rvalue) of type Node
	- idea is to copy to lvalue and steal from rvalue
	- for that we have to write a our own contructor

	struct Node {
		Node (Node &&other): 
			data{other.data}
			next{other.next} // now since the list is going to be destroyed because other is a temporary. We actually have to take values away from other
		{ // this is called a move constructor
			// idea is that instead of copying data, it should steal it
			other.next = nullptr; // else the list is destroyed when other is destroyed
		}
	}

	Now we get 
	- 2 basic constructor calls
	- 2 copy contructors 
	- 1 move constructor
	since move is not recursive, it will excecute in constant time always
	** this is one of the trickier concepts in the course, make sure you understand it **

	Since a need for move can arise when using copy operator, it could also arise when using copy assignemmt
	Node m;
	m = plusOne(n); // assignment from temp

	we can also write move assignment operator:
	struct Node {
		Node &operator= (Node && other) { // we want to steal other's data, but its assignent operator now, which means that i already have some of my own nodes
			// so you have to destroy my old data. The other is already going to be destoryed, so you simply swap your data with his data
			swap(other);
			return *this;			
		}
	}

	So if you don't define move constructor/assignment operator, the copy versions will be used.
	if the move constructor/assignment is defined, it will replace all calls to the copy constructor/assignment
	when the argument is temporary (rvalue)


---------------------------Copy/Move Elision-----------------------

	Now he will show us something that will blow our minds.. Great, just what I wanted!

	Consider this function:
	Vec makeAVec() {
		return {0, 0}; // invokes a basic constructor
	} 
	Vec v = makeAVec(); // What runs? copy constructor? move constructor?
	// well, he is not sure, so he is going to ask the compiler.. I didnt know they were that close.
	Only the basic constructor runs, which is pretty messed up
	
	It's a specific behaviour of C++

	In some circumstances, the compiler is allowed to skip calling copy or move constructors (but doesn't have to) // wtf is this?
	In this example: makeAVec writes its result({0, 0}) 
	- idea is that it writes its result directly into the space occupied by V in the caller, rather than copy or move it later
	- though you dont need to know when this stuff happens

	Another Example:
	void doSomething(Vec v) {............}
	Vec v is pass by value // copy or possibly the move constructor
	doSomething(makeAVec()); // the result of makeAVec() is written directly into the parameter.
	// this is allowed even if dropping contructor calls is going to change behaviour of the program (eg. if your constructor prints something)

	Compilers obey something like an ASIF rule // you can do anything you want, as long as its doing something that looks like what you asked.sse
	Lesson: make sure compiler is not confused by your code // you are not expected to know excetly when move/copy elision is allowed, jsut that its possible. 

	If you need all of the contructors to run: g++ can help you
	- g++14 -fno-elide-constructors // will run all of your contructors
	// but we aware how much slower your code becomes. If your compiler is allowed to skip constructors, its probably skiping thousands on them
	// not just one. So your program might slow down by a lot. (if your code is of decent length)

	In summary: Rule of 5 (BIG 5)
	- if you need a custom version of any one of:
		copy constructor
		copy assignment
		destructor
		move constructor
		move assignemnt
	- then USUALLY you need a custom version of all 5
	// circumstances that requre you to change one of them, usually require others to be changed too.

	Notice: operator= is a member frunction, not a standalone function; whereas for Vec it wasn't
	- You usually have the choice to make operator a member or not.
	- when your operator is a member, this is the first argument

	struct Vec {
		int x, y;
		...	
		Vec &operator+ (Vec &other)	{
			return {x+other.x, y+other.y};
		}
		Vec &operator* (const int k) {
			return {x*k, y*k}; // implements v*k			
		}
		// but how do we implement k * v?
		// if the first argument is not Vec, then you write it as a standalone 
	}

	Vec operator+ (const int k, const Vec &v) {
		reutrn v*k;
	}

	Special case of that is when you conside I/O operators

	struct Vec {
		ostream &operator<< (ostream &out) {
		return out << x << " " << y; 
		} // but this will make Vec the first arg;
		// which is somehting you dont want to do for sure	 
	}

	SO DEFINE <<, >> OPERATORS AS STANDALONES

	On the other hand, some operators, by the rules of c++, must be members:
		operator=
		operator[]
		operator->
		operator() // lets you treat objcets as if they were functions
		operatorT // where T is a type. Implicit consversion operator
	
-----------------------------Arrays of objects-------------------------------
Struct Vec {
	int x, y;
	vec (int x, int y):x{x}, y{y}{
		....
	}
}

Vec *vp = new Vec[5];
Vec moreVecs[3]; // these want to call the default constructor on each item, but they can't because there are no default values in Vec cosntructor

Can't initialize arrays of elements.

Options: 
	1) writing a default consturctor
	2) For stack arrays you can do the following:
		Vec moreVecs[] = {{0,0}, {1,3}, {4,5}};
	3) for Heap arrays the best thing to do is to create an array of pointers
		Vec **np = new Vec*[5];
		vp[0] = new Vec{0,0};
		vp[1] = new Vec{1,2};
		// for this method tho, you better remember to deallocate each pointer in the array and also the arrays themselves.
		for (int i = 0; i < 5; i++) {
			delete vp[i];
		}
		delete [] vp;

---------------------------Constant objects-----------------------------------

int f(const Node &n) {...........} // const objects arise often
	// there are many functions that we invoke with constant variables, which means that there are going to be a lot of const objects too

in const objects:
	1) you can't change the fields
	2) Can we call methods on const objects? 
		-> most of the methods can change the fields of the object, which violated const's rules
			-> But whats the point of having const objects if you cant pass them to methods?
				-> so you can call methods on objects, but they have to promise not to change the fields

ex:
struct Student () {
	int assns, midterm, final;
	float grade () const; // here we are making a promise that the method won't change any fields
}
	
So compiler checks that const methods don't actually modify fields and ONLY CONST METHODS can be called on const objects
You have to specify that method is constant in both the header file and the code itself. The way it works is that 
this becomes a const object pointer and you can't change it.


----------------------------Collecting usage statistics------------------------------
Now consider:
	Suppose you want to collect usage statistics on student objects, we want to find out if there is a particular student that is taking up all of our time

	We are going to add a field that for each student will tell me how many times the method is called for a particular student

struct Student () {
	...
	int numMethodCalls = 0;
	float grade () const {
		++numMethodCalls;
		return .....
	}		
}	// but this method is not const anymore, so it will not compile
// you can try removing the const, but then you cant use the code with const objects

and then he says "but but but.. this is what i want, not what i meant"

But mutating numMethodCalls, doesn't impact the student object that is being passed. So we want to make destinction between student and non student objects
	so we have to specify that mutating the numMethodCalls affects only the physical constness of Student objects, not the logical constness.
	
What we want to do is to be able to update numMethodCalls, even if the object is const.
	to do that, you declare field mutable

struct Student () {
	...
	mutable int numMethodCalls = 0;
	float grade () const {
		++numMethodCalls;
		return .....
	}		
}
// mutable fields can be changed, even if the object is const

------------------------Static fields & methods----------------------------------

what if instead of numMethodCalls tracking the number of methods calls for each particular student, we track the method calls over all students
OR
what if we wanted to know how many actual students we have created?
	For this we have the static members - a member that is associated with a class itself rather than a particular object. 

struct Student () {
	...
	static int numInstances;
	Student (int assns, int midterm, int final): assns{assns}, midterm{midterm}, final{final} {
		++numInstances;
	}
} // now there is one field shared between all of the objects, which means that if one of the objects update it, it will update everywhere

But it is not as simple as that:
	basically what we have done is we created a global variable, but within the scope of the class, so it can't be accessed from outside

So if I'm creating a global variable, does this line "static int numInstances;" declare a global variable or define it?
	If it does define it, then we are creating a new variable on every new instance. 
	if it is defined, then we will have way too many copies of the same variable
	if we declare it, then its a question who actually defines it in the first place

So we have to include it in our .cc file:
	int Student::numInstances=0; // in.cc file
Static fields must be defined, external to the class

Now, moving on to the methods:
	static member functions, follow similar set of rules, they dont depend on a specific instance
	- which means that static methods don't have a "this" parameter
	- what can static methods do then? 
		- They can access static fields, because those don't depend on specific objects
		- They can also call other static methods

Ex:
struct Student () {
	...
	static int numInstances;
	....
	static void printNumInstances() {
		cout << numInstances << endl;
	}
};

Student billy {60,70,80};
Student jane {60,70,90};
Student::printNumInstances(); // will print 2
// notice that there is no student attachment, you simply refer to Student struct

----------------------------Intervarians+Encapsulation-------------------------------
struct Node () {
	int data;
	Node *next;
	Node (int data, Node *next);
	....
	~Node() {delete next;} 
}

Node n1{1, new Node {2, nullptr}}
Node n2{3, nullptr};
Node n3{4, &n2};

What happens when these go out of scope?
	- n1 runs its destructor, whole list is deleted OK
	- n2, n3 go out of scope: n3's destructor attempts to delete the n2, but the n2 is on the stack, not the heap
	  and we get undefined behaviour, maybe a crash.

So Class Node relies on an assumption for its proper operation, and the assumption was that next was either a nullptr or allocated by new
 - this is what an invariant is called.
	- this is a logical statement that holds true, upon which Node relies.

But the problem is that while we are relying on it, we can't guarantee that it will be true all the time. You can't trust the user to use it properly
In fact, you cant't enforce any invariants // user can't interfere with our data

Ex:
you are writing stack:
 - Invariant: last item push is the first thing you pop
 - but as long as you give your user access to rearrange the underlying data.
 - this makes your ensuring that your program works very difficult
 - hard to reason about programs if you can't rely on invariants

To enforce invariants, we introduce what is called encapsulation
 - idea is that we want client to see our objects as black boxes, or capsules // something that is sealed away from the user
 implementation details are sealed away, you can only interact via provided methods
 - and thats how we get abstraction and regain control over our objects

Ex:
struct Vec {
	Vec (int x, int y); // by default things are public tho
	private: // stuff under private can't be accessed outside the structure
		int x, y;
	public: // stuff under public can be accessed by anyone
		Vec operator+ (.....);
		.
		.
		.
} 

In general: want fields to be private and only the methods should be public
 - But this is very error prone, so we would instead want to have default visibility as private
	- if the default visibility was private, then all the C will break, because it doesn't have private mode

Then c++ people decided to switch from struc t to class
Ex:
class Vec {
	Vec (int x, int y);
	int x, y;
	public: // stuff under public can be accessed by anyone
		Vec operator+ (.....);
		.
		.
		.
} 

That is the major difference between Classes and Structs, where the default visibility is private
 - so we should use classes from now on

-------------------------Encapsulated Liked Lists----------------------------

Today we want to fix our linked list class

// list.h

Class List { // we want to take advantage of the scoping mechanism of classes
	Struct Node; // we put this inside of list so that its scoped inside a list
	Node *theList = nullptr;
	public:
		void addToFront (int n);
		int ith(int n) const;
		~List () {delete theList};
}
So now we have a nested private class
- only accessible within list
- so the outsiders of this class, can't even use the word Node. All they can do is use the functions that we give them

// list.cc
#include "list.h"

struct List::Node { // nested class
	int data;
	Node *next;
	
	Node (...) {....}
	~Node (...) {....}
};

void List::addToFront(int n) {
	theList = new Node {n, theList};
}

int List::ith(int i) const {
	Node *cur = theList;
	for (int n = 0; n < i && cur; ++n, cur = cur->next);
	return cur->data;
}

Only list can create/manipulate Node objects
- Can guarantee the invariant that next is either a nullptr or allocated by new.

// So this gets the job done to secure creating bad objects with Nodes. But he is not satisfied
// "While we gained here, we have also lost." Thats deep tho...

Now we can't traverse the list from node to node, as we would in a linked list
// now this is not good because it becomes a O(n^2) time.
// we want to access the entire list in constant time, like you would normally.

But we can't expose the nodes, or we lose encapsulation

------------------------------SE Topic: Design Patterns----------------------------

The idea that has come up a lot of times and the solutions that have been studied and proven to work well
- cartain problems that arise frequenty 
- experts keep track of its solutions and reuse the best ones in similar situations
- this is the essence of a Design pattern: If you have problem X, solution Y may fix it

Was coined by 4 individuals who wrote the first book of design patterns
- they studied OOP design and wrote a book about it

So our solution to the problem that we have right now, is known as the interator pattern. 
- the idea is to not to expose the Nodes to keep encapsulation
- we will create another class that will manages the access to Nodes
- this class will be based on the abstraction of a pointer
- we will walk the list without exposing the actual pointers

Inspiration to use this when looping over a list:
for (int *p = a; p != a+n; ++p) {
	....*p..... // access the item using the pointer
}

Class List { // we want to take advantage of the scoping mechanism of classes
	Struct Node; // we put this inside of list so that its scoped inside a list
	Node *theList;

	public:

		class Iterator {
			Node *p;

			public:
				explicit Iterator(Node *p): p{p} {......}
				int  &operator*() { // the fact that this returns the reference means that we don't get a copy of the list, but the list itself.
									// so we can actually modify it later
					return p->data;
				}
				int &operator++() {
					p = p->next;
					return *this;
				}
				bool operator== (const Iterator &other) {
					return p==other.p;
				}
				bool operator!= (const Iterator &other) {
					return !(*this==other);
				}
		} // end of the iterator class
		// this is not the end, we still have to make methods that will tell us where is the start and where is the end of the list

		Iterator begin() {
			return Iterator{theList};		
		}
		Iterator end() {
			return Iterator{nullptr};
		}

		void addToFront (int n);
		int ith(int n) const;
		~List () {delete theList};
}


Client:
-------
int main() {
	List l;
	l.addtoFront(1);
	l.addtoFront(2);
	l.addtoFront(3);

	for (List::Iterator it = l.begin(); it != l.end(); ++it) {
		cout << *it << endl;
	}
}

// Most importantly, we keep the encapsulation
// and we get all of the operations in O(1)
// which means that this iteration of the list is O(n)

If you have an objection that this is way too much stuff to write down, then we will see some shortcuts now

AUTOMATIC TYPE DEDUCTION:
auto x = y; // idea is that im too lazy to write out the type for x;
// but since we know that x is being initialized to y, we will simply match their types
// auto has existed for a long time, but noone used it, so they recycled it for a new purpose
// auto used to be the opposite of static, meant that variable was on the stack, but all of the variables are on the stack by default
// so now auto has a new meaning.

Using automatic type deduction:
for (auto it = l.begin(); it != l.end(); ++it) {
	cout << *it << endl;
}

RANGE-BASED FOR LOOP:
for (auto n:l) {
	cout << n << endl;
}
// this is available for any class with methods begin(), end() that produce Iterators
// Iterator must support !=, ++(prefix), unary *

The only thing is that n is by value declaration, so n is the copy of the list, so you can change the n, but not the list.

If you actually want to modify list elements, or save copying memory:
for (auto &n:l) {
	cout << *n << endl;	
	++n;
} 

!!!!!Iterators is a big topic in C++, you have to really understand those!!!!!

Coming back to ENCAPSULATION: there is still one little loophole that we have to close
We dont want clients to create their own Iterators

List client can create Iterators directly
- the only iterator they can create is null one
auto it = List::Iterator{nullptr};
- this violates encapsulation, client should be using begin(), end()

We can make the Iterator's constructor private for this purpose:
- then the client can't call List::Iterator(.....)
- but this also menas that List can't call it

Solution we are looking for is to give List priveledged access to Iterator
- you make List a friend

Class List {
	Struct Node;
	Node *theList;

	public:
		class Iterator {
			Node *p;
			explicit Iterator(Node *p): p{p} {......}
			
			public:
				int  &operator*() { 
					return p->data;
				}
				int &operator++() {
					p = p->next;
					return *this;
				}
				bool operator== (const Iterator &other) {
					return p==other.p;
				}
				bool operator!= (const Iterator &other) {
					return !(*this==other);
				}
				friend class List; // list has access to all members of Iterator
				// can also make a specific member of a class a friend too, but we will cover that later
		}

		Iterator begin() {
			return Iterator{theList};		
		}
		Iterator end() {
			return Iterator{nullptr};
		}

		void addToFront (int n);
		int ith(int n) const;
		~List () {delete theList};
}

So now List can still create Iterators, but the client can only create them by calling begin() and end()
look into the repository for an example: "~/cs246/1169/lectures/se/"

ADVICE: you want to make as little friends as possible
// only make a friend that can do something for you otherwise it will weaken encapsulation and changing one thing will make you change everything

ONCE AGAIN:
- Keep your fields private 
- what if you want to give access, use accessor and mutator methods

Ex:
class Vec {
	int x, y;
	public:
		int getX() const {return x;} // accessor method
		void setY(int newY) {y= newY;} // mutator method
};
// This way you keep control of the structure and can validate parameters that are being passed

What about the operator<< 
- needs x, y
- can't be a member
- if you don't want to give access to getX(), getY() to everyone

You should then make operator<< a friend function
// vec.h
class Vec {
	.....
	public:
		friend std::ostream &operator<< (std::ostream &out, const Vec &v) // this is a friend intialization, you can still customize the &operator<< function
	.....
};

// vec.cc
ostream &operator<< (ostream &out, const Vec &v) {
	return out << v.x << ' ' << v.y;
}

-----------------------------Tools topic: Make-------------------------------
Separate compilation:
- g++14 -c list.cc
  g++14 -c node.cc
  g++14 -c iter.cc
  g++14 -c main.cc
  g++14 list.o, node.o, iter.o, main.o -o myprogram
- we do this so we dont have to recompile
- once you move on to bigger projects, you dont want to recompile every single file

But how do you know what has to be recompiled?
- use technology bruh, with make

What make does, is it keeps track of what parts of your programs needs to be changed
- it needs a makefile
- but then compilation is 10000000000000000000 times faster and more convenient

Create a makefile that says which files depend on which other files

Ex:
what myprog depends on: 
	main.o, list.o, node.o, iter.o // idea is that my program depends on these and if any of those change, we have to rebuild
how do you rebuild it: 
	g++-5 -std=c++14 main.o, list.o, node.o, iter.o -o myprog // NOTICE: you have to start this line with TAB, not Spaces

class Test:public Book {
	public:
	Text(string title, string author, int numPages, string topic): Book{title,author,numPages}, topic{topic} {} 
}

// Rule: if the super class had no defult constructor, subclass must invoke the superclass constructor in its MIL

still you may be thinking it is a litttle strange that the superclass fields are not visible for subclass, he will explain it later
and if you want to give the subclass access to certain superclass members, there is a way to do it:
	- you use protected visiblity
	
class Book {
	protected: 
	string title, author;
	int numPages;
};

class Text:public Book {
	string topic; // since authors can change we need create a method for that
	public:
	void addAuthor(string auth) {
		author += auth;
	}
} // although this is occaionally useful, its usually not a good idea to give subclassses unlimited access to fields

So why is it a bad idea? even though its protected? 
 - suppose you keep a collection of your book and suppose that you ust hate one author so much
 - You dont want to have any books by that author. You provide an inveriant that removes all appearences of that authors name
 - then, you can protect your class all you want from the bad author, but if your subclass can change fields of the class, then
   you have broken encapsulation because i will be able to change the author name of the existing classes

Author of C++ has regretted adding protected!!

But if you do want your subclass to access certain fields sometimes? 
 - make sure you make your fields private and provide protected methods that do your getting and setting
 - this way you still have control of what users can do and you can still enforce your invariants

class Book {
	string title, author;
	int numPages;
	protected:
	string getTitle() const;
	void setAuthor(string auth);
	public:
	Book();
	bool isItHeavy() const;
}

-----------------------------Relationship among text, Book called 'is-a'-----------------------------
 - a text is a book
 - a comic is a book

	       Book 	
			|
	-----------------
	|				|
   text           comic

Method isItHeavy - when is a book heavy?
 - for ordinary Books -> 200 pages means heavy
 - for textbooks (text) -> 500 pages means heavy
 - for comics -> 30 pages means heavy

So we go ahead and write our class Book

class Book {
	protected:
	int numPages; // although not a good idea, we will do it this time
	public:
	bool isItHeavy() const {
		return numPages > 200;	
	}
}

class Comic: public Book {
	public:
	.....
	bool isItHeavy() const{
		return numPages > 30;	
	}
}

Now lets use these objects:
Book b{"A small book", "...", 50};
Comic c{"A big comic", "...", 40};

cout << b.isItHeavy(); // false
cout << c.isItHeavy(); // true

now comes the interesting part
	- we said that inheritance type of 'is-a'
	- and if comic is a book, then there are certain things we can do

Book b = Comic{"A big comic", "...", 40}; // initializing a books using a comic object
// this is allowed, but its not what we want

Q: is b heavy now? or another way of saying it, which version of isItHeavy() runs? (Comic's method or Book's method)
A: b.isItHeavy() will give you false, book's isItHeavy() runs

Now the question is Why?
A: Imagine what happens in memory when we do this
Book will look something like this:
 - title
 - author
 - numPages
And the comic book is going to look like this:
 - title
 - author
 - numPages
 - hero

the compiler has enough space to only keep a book
	- so what we are trying to do is to fit an object with 4 fields into a hole of 3 fields
		- trying to fit a comic object where there is only space for a book object
	- at this point you lose the field hero and then you simply treat your comic as a book

This phenomenon is called SLICING // the hero field is chopped off and comic is coerced into a book

so b = Comic {...};
 - converts comic into a book and so Book::isItHeavy() runs
// if this was the other way, then we'd have memory leaks all the time

Q: Now you may wonder, what if the comic has the same amount of fields as the Book?
A: Does not matter, as long as you initialize super class using a cublass, it 
	will be sliced anyways and the superclass' members will run

Q: Can you initialize a comic with a book? 
A: The question then is who is the hero? and since you can't answer this, no you can't

Q: what constructor gets called? 
A: "I suppose it's actually a move constructor"

This idea is based around limited memory spaces, but if we work with pointers, 
	things change all of the sudden, because we dont move memory around as much
 - when accessing objects through pointers
 - slicing is uneccesary
 - and it doesn't happen

Ex:
Comic c {..., ..., 40, ...};
Book *pb = &c;
Comic *pc = &c;

cout << pc->isItHeavy() // true
cout << pb->isItHeavy() // false

 - Still, it shows that its not heavy and this time there was no slicing, we created 
 	a comic book and just pointed two pointers at it
 - Same object behaves differently depending on what kind of pointer is pointing at it

Q: So what is the rule? what determines what method is run?
A: The compiler is using the type of the pointer or refrence to decide which isItHeavy() to run
	- it does not consider the actual type of the object

And in many ways, this outcome is unintuitive, it means a comic is only a comic 
	if it is pointed at by a comic pointer
// might not be what we want

Imagine you sitting on your bed and pick up a heavy comic
 - you don't say that oh this is a light comic that I'm viewing as a book
 - you say oh, it's a heavy comic

How do we make a comic, even when pointed at by a book?
 - Declare the method VIRTUAL!

class Book {
	....
	public:
		Book(....);
		virtual bool isItHeavy() const {.....};
};

// and then in your subclass

class Comic:public Book {
	....
	public:
		Comic(....);
		bool isItHeavy() const override {....};
}

// Now, if we do the same thing:
Ex:
Comic c {..., ..., 40, ...};
Book *pb = &c;
Book &rb = c;
Comic *pc = &c;

cout << pc->isItHeavy() // true
cout << pb->isItHeavy() // true
cout << rb.isItHeavy() // true

Override is new in C++ // only since v.11

Ex:
Book *myBooks[20];
.
.
.
for (int i = 0; i < 20; i++) {
	cout << myBooks[i]->isItHeavy() << endl;
}

Accomodates multiple types under one abstraction -> POLIMORPHYSM ("many forms")

Now that we have inheritance, we have to redo all of the BIG 5

-----------------------Inheritance: Destructor------------------------

class X {
	int *x;
	public:
		X(int n): x{new int[n]} {}
		~X() {delete [] x}
};

class Y: public X{
	int *y;
	public:
		Y(int m, int n): X{n}, y{new int[m]}
		~Y() {delete [] y;} // notice how we don't delete X, even though it inherits it. 
};

Q: Not deleting X, is that wrong?
A: There is a big problem if we did have a leak, because x is private in X
	- when you create an object, the super class constructor runs first
	- when you destroy an object, the superclass destructor runs last

What if we do this now? 
Ex:
X *myX = new Y{10, 20}
delete myX;
// he ran it and nothing crushed
// he ran it with valgrind and found a memory leak
// only x was freed, not the y

He deleted x poitner and x's destructor ran. But he destructor for y didn't run // since its a subclass of x
 - so we didnt have a problem, when we deleted x, through y's destructor
 - but we do have a problem when we delete y using x's destructor // because y is not a superclass of x

Q: How do you make sure that the deletion through the superclass will call subclasses' destructor?
A: Make the destructor virtual

class X {
	int *x;
	public:
		X(int n): x{new int[n]} {}
		~X() virtual {delete [] x}
}; // you dont have to add override to the destructor in Y

So there is a piece of advice:
 - ALWAYS make the destructor virtual in classes that are meant to have subclasses
 - this is true, even if the destructor is not doing anything (has an empty body)

On the other hand, if a class is not meant to have subclasses, declare it final:

class Y final:public X {
	....
	....
	....
}

---------------------------Pure Virtual Methods + Abstract Classes-------------------------------

class Student {
	protected:
		int numCourses;
	public:
		virtual int fees();
}

2 kinds of Student: Regular + Co-op

class Regular:public Student {
	public:
		int fees() override;
} // regual student's fees

class Coop:public Student{
	public:
		int fees() override;

} // coop student's fees

What should we put for Student::fees()?

Not sure, every student should be regualr or co-op

Can explicitly give Student::fees() No implementation

class Student {
	....
	public:
		virtual int fees() = 0; // methos has no implementaion ****
		// called a pure virtual method
}

A class with a pure virtual methods cannot be instantiated:
Student s; // will not work

this is called an abstract class and its purpose is to organize subclasses
- Abstract classes are needed to create concrete subclasses out of them
- A class is called abstract if it has one or move pure virtual methods

Subclasses of an abstract class are also abstract, unless they implement the pure virtual methods.

If a class is not abstract, then its concrete

UML: Virtual + pure virtual methods::italics

static _____ underline

At this point of time, we usually see how inheritance plays off in the BIG 5, 
	but instead he is going to focus on the assignment

-------------------------------------Templates-------------------------------------------

This is very big in C++, but we are going to spend very little time on this

Earlier on, we had something like this:

class List {
	struct Node;
	Node *theList;
	.....
};

struct List::Node {
	int data;
	Node *next;
}

We went into a lot of trouble to implement this, and all was good because we got it to work.
Q: But what if we now want a string linked list?
Q: Do we have to write a whole new class now?
A: Yes, we do, but C++ can help us, if we create a template class parametized by a type

template <typename T> class Stack {
	int size;
	int cap;
	T *contents;
	public:
		Stack() {.......}
		void Push(T *) {.......}
		T Top() {.....}
		void Pop() {......}
} // now istead of using an int everywhere, we use a pointer to contents

template <typename T> class List {
	struct Node {
		T data;
		Node *next;
	}
	Node *theList;
	public:
		class Iterator {
			Node *p;
			explicit Iterator(Node *p): p{p} {}
			public:
				T &operator*() {return p->data;}
				....
				....
				....
		}
	T ith(int i) {....}
	void addToFront(T n) {....}
} // the idea is instead of specifying what type of data is returned in every method, we will simply say T

The benefit is that now our client can say:
List<int> l1;
if we want a list of lists of int:
List<List<int>> l2;

l1.addToFront(3);
l2.addToFront(l1);

This list template still has a begin/end method and and interator class, 
	so we can still iterate it, the way we did before:

for (List<int>::Iterator it = l1.begin(); it != l1.end(); ++it) {
	cout << *it << endl;
}

or indeed, what we did before, still applies:

for (auto n:l1) {
	cout << n << endl;
}

Every time we create a new class using templates, we are actually creating brand 
	new classses, it's just that we don't see it anymore

"this is some things about c++, it starts relatively easy, with strings and other bs and then you get into writing your own assignment operator." 
"Suddenly, c++ will get really difficult, but there comes a point where difficulty level slows down. Right now we are going to hit a crest, where its not as difficult"

-------------------------------------------The standard Template Library (STL)--------------------------------------
Much of the stuff that comes with C++ is written out as templates, so you can reuse
	it for your own purposes

Large # of useful templates:
Eg: dynamic-length arrays: VECTORS
	In the next assignemnt (4), it says you are not allowed to use array's functions
	delete and new, because they want us to use this:
	vectors will manage all the heap allocated arrays for you

#include <vector> // we have to be a little bit careful here
using namespace std;

// recall the curly brackets vs. round brackets argument
// in general curly is for c++ and round for c, so you should be using curly 99% of the time
// except for this time, tho. ik, its ucked up

vector<int> v {4, 5}; // gives you a vec(4, 5)
vector<int> v (4, 5); // gives you a vec(5, 5, 5, 5)

// The {} expression is called the initializer list
// if you write a function that takes in {}, you can intiialize arrays using that

v.emplace_back(6);
v.emplace_back(7); // now we have (4, 5, 6, 7)
// we can do this forever and the array will keep growing forever and this array is also STACK allocated

Looping:
Eg:
for (int i = 0; i < v.zise; ++i) {
	cout << v[i] << endl;
} // just like an array, the vector standard guarantees that its going to behave as an array

for (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
	cout << *it << endl;
} // also can use auto here

OR:

for (auto n:v) {
	cout << n << endl;
}

Wow, he brought up the frist midterm...

To iterate in reverse:
for (vector<int>::reverse_iterator it = v.rbegin(); it != v.rend(); ++it) {
	cout << *it << endl;
}

v.pop.back() // remove last element

Use iterators to remove from inside a vector:
	auto it = erase(v.begin()); // erases element 0
	it = v.erase(v.begin() + 3) // erases item 3
// vectors' iterators support pointer arithmetics
// not all iterators are created equal, so not all of them can do it 
// One of the rules that comes to vectors, when you use anything that shuffles items around (deleting elements),
// you shold not be using iterators with deletion of elements

instead, use this:
it = v.erase(it); // erases item pointed at by it
it = v.erase(e.end() - 1); // returns an iterator to the item past the item jsut removed.

Now that we are allowed to use vectors, we should embrace them... We have just 
	eliminated an entire class of memory management

v[i] - returns the ith element of v // this method call is completely unchecked, just like with arrays
// if you go out of bounds, you are in for some fun behaviour
// might prefer using iterators, because those never go out of bounds

on the other hand, there is another version of iterator that is checked:
v.at(i);

Q: what happens when you break the rules and try going out of bounds with .at()?

Problem: 
	- Vector's code can detect errors, but it doesn't know what to do about it
	- Only the client can respond on how we should behave here, but they can't detect the error

C solution:
	- if a function fails, it returns status code
	- set the global variable "errno" to an error code, but then you are supposed 
		to check it all the time, but ain't nobody got time for that
	// now we have this entire mess that discourages programmers to do error checks, because they are inconvenient

C++ solution:
	- when an error condition arises, the function raises an exception. By default, execution stops
	- but you can also write HANDLERS to CATCH exceptions "because apparently they are like baseballs"

vector<T>::at() raises an exeption std::out_of_range, when it fails
// we can handle it as follows

#include <stdexcept>
.....
try { // inside the curly brackets go the statemnts that might fail due to specified error
	cout << v.at(1000000000000) << endl;
} catch (out_of_range r) {
	cerr << "Range error: " << r.what() << endl;
} // you are allowed to ask what? Which will give you some extra info on the error


------------------------------------Exceptions----------------------------------
Now consider:
void f () {
	throw out_of_range{"f"} // "f" is what()
}

void g() {f();}
void h() {g();}

What happens:
	- main calls h
	- h calls g	
	- g calls f
	- f throws out_of_range

// enter more here

A handler can do part of the recovery job // execute some corrective code
 + raise another exception

try {...}
catch (Some_type s) {
	...
	throw Some_other_error {"..."}; // can be the same one
}


Throw VS. Throws:
	Since exceptions are classes, we can also have subclasses
class SomeType {
	class SpecialSomeType {
	...
	}
}

"This is similar to pass by reference vs. pass by value"
Throw: actual type of s is retained 
// ^pass by reference

Throws creates a new exception of type SomeType, even if s itself was already specialtype
// ^pass by value

Occasionally, you want to say, idc what type of error it is, i simply want to catch it
- No, you cant do that 
// there is a top level exception type, and all the other types inherit from it 
- but you might still want to do it, but how? 

"A handler can act as a catch-all":
try {....} // these dots stand for the code
catch (...) { // you must put the three dots in to catch all exceptions, like "..."}

Apparently exceptions that you throw, don't actually have to be objects, so you 
can't call .what() on all of them, because they simply dont have that method

check as SICK example of recursion, factorials and throwing errors in 
lectures/c++/exceptions/exfact.cc
	OR
lectures/c++/exceptions/exfib.cc

new helper thing in Ubuntu:
	time ./myprog // to see how long the program takes
	- you look for "user" for acutal time for your code to execute
	- "real" means how long you took to run your program

OK so he did the following:
	- he timed his recursive fibonacci sequence and timed his exfib.cc function
	- the recursive ran in 0.018s and the one with exceptions took 11.716s

Moral: "dont overuse exceptions! they might be useful, when you actually need them tho"

Now we will learn how to define our own exception class: 
Eg:
class BadInput {};

try {
	int n;
	if (!(cin >> in)) throw BadInput{};
} catch (BadInput &s) {
	cerr << "input not well-formed" << endl; 
	// HE caught the exception by reference this time and in general thats what you
	// should always do
}

Q: why catch by reference? 
A: 
- supresses copying
- exception that you caught might be a subtype and you don't want it to be sliced
- it's the proper way to work with objects

Some standard exceptions:
- length_error // attempting to resize strings/vectors that are too long
- bad_alloc // is what happens when "new" fails
// remmeber how he told us that sometimes new fails? 
// if it fails, it throws an exception, which if not handled, will crash the whole program

Much more on exception later! // good enough for A4

We are going back to Design Patterns

------------------------------Guiding Principle---------------------------------
Guiding principle: program to the interface, not the implementation:
- You start with an abstract base class, to define the interface
- You work with pointers to abstract base classes and call their methods
- Concrete classes can be swapped in/out
- It gives you abstraction over variety of behaviours

Lets get back to the interator pattern:
Eg:
class List {
	Struct Node;
	...
	public:
		class Iterator {
			....
			....
			....
		};
	...
}; // what if you want to iterate over other object
// you can try writing a class called abstract Iterator
// where you will put all the things that you want

class AbstractIterator {
	public:
		virtual int &operator*() = 0;
		virtual AbstractIterator $operator++() = 0;
		virtual bool operator!= (const AbstractIterator &other) =0;
		virtual ~AbstractIterator();
};

// now what he can do is this? 
// what if he has another data structure? 

class set {
	....
	public:
		class Iterator:public AbstractIterator {
			....
			....
		};
	....
};

// if you still saying "So what?" here is what he does next

What if you want to write a function that will print all the items out of the list?
	- but instead of giving it out list, we give it an interator

Then you can write code that operates over Iterators
Eg:
void foreach(AbstractIterator start, AbstractIterator end, void(*f)(int)) {
	while (start != end) {
		f(*start);
		++start;
	}
}; // works over lists and sets

This is the main thrust behind the design patterns, where you can have abstract classes
so that you can have concrete behaviour for every operation and never make mistakes

Another Design Pattern coming up now!!!

---------------------------Observer Pattern------------------------------------
Very useful, might get a lot of milage on A4 and A5

Idea of Publish-subscribe model:
- you have one class: publisher/subject, which generates data
- one or more subscriber or observer classes, which receive data and react to it

Eg:
- your publisher is an excel spreadsheet
- your observers are graphs
	- idea is that when the sells change, the graphs update

Can have all kinds of observer objects:
	- observer attached to a cell of a spreadsheet, which notifies you when values go < 0
	
since there are so many possibilities you can't code it wrong
- you should make it so that it works all the time and wont care who the observer is
- subject should not need to know all the details

Observer pattern:
- we start with abstract classes:
- idea is that subject has observers
- it has them, but doesn't own them
- UML diagram will be uploaded in the folder git_notes/

sequence of method calls:
1) Subject's state is updated
2) Subject's Notify observer must be called // calls each observer's notify
3) Each observer calls ConcreteSubject::getState to query the state & reach accordingly

Example: Horse Races
- subject: big scoreboard in the middle of the field that tells you who is winning
- observers: individual betters 
			- declare victory when their horse wins

Let's write this // damn son

class Subject {
	vector<Observer*> observers;
	Subject() {};
	bool sttach (Observer *o) {observers.emplace(o);}
	void detach (Observer *o) {...} // take observer out of the list
	void notifyObservers () {
		for (auto &ob:observers) ob->notify();
 	}
	virtual ~Subject() = 0;
}

Now, we have a problem // he points to the subjcet class
"This class is not abstract, it doesn't have any virtual methods"
"Here is the trick if you want abstract class and dont have any methods that are virtual"
"You make the destructor pure virtual"

NOTE: a virtual destructor must always be implemented!!!!

Subject::~Subject() {...};

Why? because when destrcutor is run, the super class destructor will be called, so it better exist

public Observer {
	public:
		virtual void notify() = 0;
		virtual ~Observer();
};
Observer::~Observer() {};

class HorseRace: public Subject {
	ifstream in; // source of data
	string last_winner;
	.
	.
	.
	public:
		HorseRace(const string &source): in{source} {}
		bool runRace(); // set last winner
		// need a bool because you want to know when there are no more winners
		// read in winners, if it read it successfully, return true, else false
		string getState() {return lastwinner;}		
}

class Better:public Observer { // every better has a race that they are watching
	HorseRace *subject;
	String name, myHorse;
	public:
		Better(...) { // easy one, just set your hourse's name and notify the subject that we are watching it
			subject->attach(this); // puts this into the list of observers in Subject		
		}
		~Better() {subject->detach(this);}
		void notify() {
			String winner = subject->getState();
			if (winner == myHorse) {
				cout << "YAY!" << endl;
			} else {
				cout << "Double or nothing" << endl;		
			}
		}
}

// how we do the main.cc
HorseRace hr;
Better Larry(&hr, "Larry", "RunsLikeACow");
....
while (hr.runRace()) {
	hr.notifyObservers();
}

The key to this pattern is that it doesn't have to be about horse racing, it can be about anything
Where you are simply watching the state of a class and notify others when it changes and 
do things accordingly to those changes

---------------------------------Decorator Pattern------------------------------------

Want to enhance Object at run-time-add functionality/features

Eg:
Window system:
	- Start with a basic Window
	- Lets say that you typed so much text into that window that you need more space
	- Then a scroll bat suddenly appears
	- then you move your cursor to the top of the screen
	- and the menu bar appears too

Idea is that these things change at runtime and we want to take advantage of that
 - This is called decorator pattern

// the UML Diagram

Class component:
	- defines the interface
	- operations your objects will provide

Concrete Component:
	- implements the interface

Decorators:
	- all inherit from decorator, which inherts from component

So, every decorator is a component, "AND" every decorator "HAS" a component

Here is a key ho this all fits in with a window:
 - A window with a scroll bar is a kind of window and has a pointer to the underlying plain window
 
 - Similarly, a window with a scroll bar menu is a window and has a pointer to a window with a scroll
	bar, which itself has a pointer to a plane window

 - All of these inherit from an abstract Window class, so the window method can be used polymoprhically
	on all of them // you could describe it as similar to stack logic

Eg of the decorator pattern, called Pizza

// insert diagram here

// open diamon means aggredation, means hasA, not ownsA

 - Basic Pizza is crust and sauce

class Pizza {
	public:
		virtual float price() const = 0;
		virtual string desc() const = 0;
		virtual ~Pizza();
}

class CrustAndSauce:public Pizza {
	public:
		float price() const override {return 5.99;}
		string desc() const override {return "Pizza";}
};

class Decorator:public Pizza {
	protected:
		Pizza *component;
	public:
		Decorator(Pizza *p): component{p} {}
		virtual ~Decorator() {delete component;} // ? tho
		// the question is should the component supposed to delete the component underneath itself? 
} // for now we will say that we can't remove toppings from a pizza

class StuffedCrust:public Decorator {
	public:
		StuffedCrust(Pizza *p): Decorator{p} {}
		float price() const override {
			return component->pricE() + 2.69;
		}
		string desc() const override {
			return component->desc() + " with stuffed crust";
		}
};

so in your main, you will have something like this:
// main.cc

Pizza *p1 = new CrustAndSauce;
p1 = new Topping("Cheese", p1);
p1 = new Topping("Jelly Beans", p1);
p1 = new StuffedCrust(p1);

cout << p1->desc() << ": " << p1->price() << endl;
delete p1;

And we are done with the decorator pattern


-----------------------------------Inheritance in the BIG 5-----------------------------------------
Now we are going to go back and have a discussion about the BIG 5 and inheritance

We have already seen the destructor that was inherited, what about the other ones tho?

we got a class book..

----------------------------------Inheritance and Copy/Move-----------------------------------------

class Book {
	// deifnes copy.move constructors, copy/move operator=
}

Then we inherit it in a subclass..
	 But suppose we do not define copy and move in the subclass..

class Text:public Book {
	....
	public:
		// Does not define copy/move operations
}

Text t {"Algorithms", "CLRS", 500, "CS"};
// so what happens when we do this?
Text t2 = t; // remmeber we have not defined copy/move operations for Text

Remember: copy constructor is given to you for free.. 
 - calls Book's copy constructor
 - then goes field by field (i.e. default behaviour) for Text part
 - same for other operations

// this is good because you kind of want this to happen.. but there are a few things that we have to know

Suppose you actually want to write move/copy operations for your subclass, how would you do that?

To wirte your own operations:

Copy constructor:
Text::Text(const Text &other): Book{other}, topic{other.topic} {} // copy constructor

Copy Assignment operator:
Text &Text::operator= (const Text &other) {
	Book::operator=(other); // we want to use the one in Book
	topic = other.topic
	return *this;
} // copy assignment


Move constructor:
Ver 1.0
Text::Text (Text &&other): Book{other}, topic{other.topic} {} // this is wrong
// notice &&other is an lvalue that points to the rvalue of the other
// we are not taking advantage of the move constructor's efficiency because we are actually using a copy
// constructor from the Book

Ver 2.0
Text::Text (Text &&other): Book{std::move(other)}, topic{other.topic} {} // this is strill wrong
// because other.topic is also an lvalue that is pointing to the rvalue
// so again, we are copying it instead of moving it, so we have to fix that

Ver 3.0
Text::Text (Text &&other): Book{std::move(other)}, topic{std::move(other.topic)} {} // this is correct

Move Assignment operator:

Ver 1.0
Text &Text::operator= (Text &&other) {
	Book::operator=(other); // this is a copy assignemnt
	topic = other.topic; // this is a copy assignement
	return *this;
} // we actually want other to be treted as an rvalue, so we have to change something

Ver 2.0 
Text &Text::operator= (Text &&other) {
	Book::operator=(std::move(other));
	topic = std::move(other.topic);
	return *this;
} // this is a correct version

Notes:
 - even tho other points at an rvalue, other itself is an lvalue and so is the other.topic
 - std::move(x) forces an lvalues x to be treated as an rvalue, so that the move version of the operations run
 - everything we have done here is equivalent to the default, so if you want to do default things, then
	you dont have to change anything, you are given these things for free



----------------------------------------Partial Assignment-----------------------------------------
Text t1 {...}, t2 {...};
Book *pb1=&t1, *pb2=&t2;

What if we do this? 
*pb1 = *pb2; // so we are assigning text2 to text1 through a book pointer

so what happebed is that only the book part was copied over, and the text topic did not copy
 - This is called partial assignment // it is not slicing tho
	// we are not trying to fit a large object into a small hole

Why was only the book part copied? 
 - only the book assignment operator ran
 - since we were using the book pointers

How can we fix this?
 - we want to stop using pointer to decide which assignment operator runs
 - try making operator= virtual

class Book {
	...
	public:
		virtual Book &operator= (const Book &other) {....}
};

class Text {
	...
	public:
		Text &operator= (const Book &other) override {...}
		// we have to use Book here in order to override the operator, otherwise it wont be an override
}

Note:
 - the different return types are OK (as long as return a subtype by reference)
 - but the parameter types must be the same or its not an override. And won't compile
 - parameters not macthing => violates is-A

Making virtual operator= forces us to take any book as the second part of the operator=
 - this means that assignment fo a Book object to a Text var would be allowed:
Eg:
Text t{..};
Book b{...};
Text *pt = &t;
Book *pb = &b;
*pt = *pb; // uses a book to assign a Text, which is very BAD!!!
// but it will still compile tho.. 

Also:
Comic c{...};
Comic *pc = &c;
*pt = *pc; // even worse, we can assign book as a comic

if operator= is non-virtual
 - you get partial assignment through base class pointers
 - if it is virtual, then the compiler allows to mixed assignment
No matter what choice you make, traouble awaits..

Whats the solution?
 - is a text really a book?
 - is comic really is a book?
 - we said for example, all books are heavy if they are over 200 pages, and textbooks heavy over 500 pages
 - so they are kind of different
 - we have been treating our super class book as a specific class rather than a super class
 - Recommendation: all super-classes should be abstract!

He suggests we rewrite the hierarchy
// insert the diagram for new book hierarchy

class AbstractBook{
	string title, author;
	int numPages;
	protected:
		AbstractBook &operator= (const AbstractBook &other); // prevernts assignment through base class
		// pointers from compiling, but still makes the implementation available to sublasses
	public:
		AbstractBook(...);
		virtual ~AbstractBook() = 0;
}

class NormalBook: public AbstractBook {
	public:
		NormalBook(....);
		~NormalBook(...);
		NormalBook &operator= (const NormalBook &other) { // now we dont have to override like we did b4
			AbstractBook::operator=(other);
			return *this;
		}
};

// to finish other classes, its an excercise for us

So can you do partial assignment now? 
operator= is not virtual, no mixed assignment

NormalBook n1 {...}, n2 {...};
AbstractBook *pa1 = &n1, *pa2 = &n2;
*pa1 = *pa2; // won't compile

// but our abstractBook operator= is protected, so the client cannot use it..
// the code will not compile
// so no partial assignment either, because operator= is protected

Recommendation: Always make your classes that you inherit from abstract
 - you should have an emply shell class and then Phill it up // $2.25 shots at Phill's

---------------------------------Factory method pattern--------------------------------------------
scenario: We are writing a video game
 - there are two types of enemies..
 - turtles and bullets
 - idea being turtles are easier to beat than bullets
 - system randomly sets turtles and bullets
 - but bullets become more frequent closer to the end

// insert uml here

Idea is that you never know exactly which enemy is comes next, so can't call turtle/bullet 
constructors directly
 - instead of calling constructors directly
 - we put a factory method in level that creates enemies

class Level {
	public:
		virtual Enemy *createEnemy () = 0; // factory method
		...
};

class NormalLevel: public Level {
	public:
		Enemy *createEnemy() override {
			// create mostly turtles
		}
};

class Castle: public Level {
	public:
		Enemy *createEnemy() override {
			// create mostly bullets
		}
};

// then the client:
Level *l = new NormalLevel;
Enemy *e = l->createEnemy(); // we dont actually know what enemy we get, but we know that it will
// be chosen based on the rule that is created inside the appropriate level


-----------------------------------Template Method Pattern-----------------------------------------
want subclasses to override superclass behaviour, but some aspects must stay the same.

Eg:
There are red turtles + green turtles

class Trutle {
	public: 
		void draw() { // only draw() is the template method
			drawHead();
			drawShell();
			drawFeet(); // the only difference between green and red turtle are their shell colours
		}
	private:
		void drawHead();
		void drawFeet();
		virtual drawShell() = 0;
};
// the sublclasses dont get to decide what it means to draw a turtle, they can only decide on
// what the tutle's shell will be
The overall behaviour cannot be changed, but we can fill in certain blanks that we give access too
Note: 
	sublass can't call drawShell() because its private, but it can still override it tho, to adjust
	the colours

class RedTurtle:public Turtle {
	void drawShell() override { /*draw red shell*/ }
};

class GreenTurtle:public Turtle {
	void drawShell() override { /*draw green shell*/ }
};

Sublasses dont have the power to change what it means to draw a turtle (i.e. head, shell, feet)
but they can change the way the shell is drawn

Apparently the template method is the most common template ever and is always encouraged
to be used everywhere

Extension: the Non-virtual Interface (NVI)
 - a public virtual method is really two things:
	- saying to a clint, here is a function you can call and this is what it will do
		(a.k.a. interface to the client, with pre/post conditions)
	- you are saying to a subclass, you can do anything you want here
		(a.k.a. interface to subclasses, a "hook" to insert specialized behaviour)
	// these two things don't match together very well

Hard to separate these ideas if they are tied to the same functions..
 - what if you later want to separate the customizable behaviour into two functions?
 - thats when you make your pure virual methods private
 - this way the client won't have to worry about changing behaviour
 - while sublclasses can override to customize method for their purposes

 - how can you make sure that overriden functions conform to the pre/post conditions

The NVI idiom says:
 - "all public methods should be non-virtual"
 - "all virtual methods should be private or at least protected"
 - one exception, the destructor must always be public

Eg:
class DigitalMedia {
	public:
		virtual void play() = 0;
};

to turn it into an instance of NVI, write it like this:

class DigitalMedia {
	public:
		void play(){ 
			doPlay();
		}; // can add before/after code
		// check copyright before playing
		// update the play count after the thing has been played
	private:
		virtual doPlay() = 0;
} // now what client looks at and what subclass looks at are different
// client can still play with consistent behaviour
// subclass can override doPlay() for specific behaviour

This extends from the template method:
 - put every virtual method inside a template method


------------------------------------------Maps--------------------------------------------
"Hope these help you to navigate through the CS life"

map<string, int> m;
m["abc"] = 1;
m["def"] = 4;

cout << m["ghi"] << endl; // wont crash, will only print 0
// the rule is that if the key is not present, it is inserted and the value is default
// constructed. For ints that mean 0
cout << m["abc"] << endl; // prints 1

to delete
m.erase("abc");

To check if something is present in the map
if (m.count("def")) // will return 0=notFound, 1=Found
// there is also multimap where things can occur more than once.. 
// but that is outside the scope of the program

---------------------------------------Iterating over maps----------------------------------------
supports iterator objects
 - returns objects in sorted order by key
 - implemented as a binary search tree

if you want to get data in the order that you put them in, then you are using the wrong data structure

Maps use a structure called std::pair to store its objects in groups of two, a pair has .first() and .second() fields
for (auto &p:m) {
	cout << p.first << " " << p.second << endl;
}

p's type is std::pair<string,int> found in <utility>

p.first and p.second are fields, not methods
"Pair is unique because it is declared as a struct, not a class"

is it bad that everything is accessible together? 
 - the goal of pair is to stick two things together
 - if you want encapsulation, then you should do something about it
 - so as long as we are talking about objectives of pair, its doing just fine

-------------------------------------Visitor Pattern-----------------------------------------------
This is different from the factory method because this uses the idea of double dispatch. In other words
there are 2 things that are going to define the behaviour of a function, whereas in Factory pattern, 
we only check to which subclass the method belongs.

Eg:
getting back to the game example:

we have abstract class Enemy:
 - we have a subclass Turtle
 - we have a subclass Bullet

we have an abstract class Weapon:
 - we have subclass stick
 - we have subclass Rock

- effect of a weapon depends on type of enemy and type of weapon

We want something like this:
	virtual void(Enemy, Weapon)::strike(); // inspiration, not actual code
If we put this method in Enemy - choose based on enemy, not weapon
If we put it in method Weapon - we choose based on weapon, not enemy

To get dispatch based on both (double dispatch) 
 - trick of combining virtual method overriding with overloading

class Enemy {
	virtual void beStruckBy(Weapon &w) = 0;
};

class Turtle: public Enemy {
	void beStruckBy (Weapon &w) override {
		w.strike(*this);
	}
}

class Bullet: public Enemy {
	void beStruckBy(Weapon &w) override {
		w.strike(*this);
	}
}
// notice that the both implenmentaions have the same code
// why didnt we just put that code in out abstract class?
"But, i claim that these two methods are not the same" 
and this is true because we have different this objects that are calling the function
 - this is where the overloading comes in, we are going to be calling two different versions of strike
 based on which *this called it
 
class Weapon {
	virtual void strike (Turtle &t) = 0;
	virtual void strike (Bullet &t) = 0;
	// we have a turtle version of strike and a bullet version of strike
}

class Stick:public Weapon {
	void strike (Turtle &t) override {
		// we know that this is striking turtle with a stick
	}
	void strike (Bullet &b) override {
		// we know that this is striking bullet with a stick
	}
}

// you client will end up with something like this:

Enemy *e = new Bullet{....};
Weapon *w = new Rock{...};
e->beStruckBy(*w);
// so what happens here?
// how does it all work?
 - we start with a fact that bestruckby is a virtual method of enemy
 - so we know that the type of enemy we have is a bullet
 - bullet.bestruckby() runs and calls weapons stike, where *this has type bullet
 - therefore the bullet's version of weapon::strike is chosen at compiling 
 - since both of weapon's methods are virtual, we end up taking the rock version of it
 - runs rock::strike(Bullet &)
 
There is another use for the Visitor Pattern and its going to look completely different:
 - Visitor can be used to add functionality to existing classes, without changing or recompiling the
   classes themselves
   
Eg: add a visitor to the Book hierarchy

class Book { // book is same as enemy in prev example
public:
	virtual void accept(BookVisitor &v) { v.visit(*this); }
	// if you just leave a visitor here you can let someone else decide what the visitor does to the book
	// and write code for it later
}

class Text:public Book {
public:
	void accept (BookVisitor &v) override {
		v.visit(*this);
	}
	// accept is the same as the bestruckby in the prev example
}

class BookVisitor { // same as the weapon in prev example
	virtual void visit(Book &b) = 0;
	virtual void visit(Text &t) = 0;
	virtual void visit(Comic &c) = 0;
	// this visit does the same thing as what strike did before
}

"What do i do with this now? what is this good for?"
 - we want to have something that acts as a virtual function, but does different things
 
Application:
 - Track how many of each type of books we have
 - for books, want to categorize by author
 - for text, want to categorize by topic
 - for comics, want to categorize by hero
 
Use a map<string,int>
Could add a virutual updateMap method to each class, but instead we are going to write a visitor

class Catalogue:public BookVisitor {
	map<string,int> theCatalogue;
public:
	map<string,int> getCatalogue() {return theCatalogue;}
	void visit(Book &b) override {
		++theCatalogue[b.getAuthor()];
	} // what if the author is not there, it will make it automatically with count 0
	// but since we are incrementing by 1 on the spot, we get count of 1 at the end
	void visit(Text &t) override {
		++theCatalogue[t.getTopic()];
	}
	void visit(Comic &c) override {
		++theCatalogue[c.getHero()];
	}
}

// damn, son.. holy sweet god - jesus

Ok, so he tried compiling it and it didn't work

main -> includes Book -> includes BookVisitor -> includes Text

if text inherits from book, then it should know about it before we declare text, so now we have this:

main -> includes Book -> includes BookVisitor -> includes Text -> includes Book
// won't include the book again because of the include guide

Now we have a circular include dependency 

----------------------------------Including vs. Forward declaration------------------------------------------
So:
 - text doesn't know what book is
 - we ask ourselves: how many of these includes are really needed
 
Q: when do you really need to include? and when you can get away with forward declaring?

Consider: Suppose we have a class A

class A {....};

// #include "A.h"
class B:public A {...};

// #include "A.h"
class C {
	A myA;
}

// class A;
class D {
	A* myAp;
}

// class A;
class E {
	A f(A *);
}

The question is which of these 4 require include and which are ok with just a forward declaration?
 - D doesn't need one
 	because D doesn't need to know how big A is in order to initialize D (add class A;)
 	// pointers are all the same size
 	
 - C needs one because it wants to know the size of A in order to initialize the object
 
 - B need to know all the fields of A since it inherits form it
 
 - E doesn't need one either. 
 	Does size of A affect the E? No, f is a function that uses A* as one of the parameters
	it does not need to know the exact size of A and all of its fields

Moral: "If you don't need an include, then don't do it"
When class A changes -> only A, B, C need recompilation

Now, keep in mind again that its a whole different story in .cc files

In the implementions of D, E:
"e.cc"
	void E::f() {
		myAp->someFunction(); // now i need to know about class A
	}
// now you still include your A.h here,but you only do it in the .cc file

Do the #include in the .cc file, instead of the .h file (where possible)
// you can include as many .h in your .cc files as you want
// this is because you never inlude .cc files from .cc files
// So this way you wont get looped includes

Now lets get this thing working!

"He is not quite done on compilation dependencies" 

Now consider the Xwindow class:
 
class XWindow {
	Display *d;
	Window w;
	int s;
	GC gc;
	unsigned long colours[10];
public:
	.....
}
// Do you know what these fields do? 
// you actually don't have to know, beacause they are private data, you should not care about it
// if this is private data and I can't interact with it anyways, why must I see them?

"This is an esthetic element, where we dont care about the fields, so we don't want to see them"
"If we add or change a private member - all clients must recompile"

 - It may be better to hide these things even more than when they are private fields
 
------------------------------------------Bridge Pattern-------------------------------------------

Solution: the PIMPL idiom
 - short for "PoInter IMPlementation"
 - to do it, you move all the private fields into a separate class and simply point to it
 
create a class XWindowImpl:
"XWindowImpl.h"
#include <X11/Xlib.h>

struct XWindowImpl {
	Display *d;
	Window w;
	int s;
	GC gc;
	unsigned long colours[10];
} // it has all the private data

then our "Window.h" will look like the following

class XWindowImpl; // no need to include Xlib.h, forward declare the implementation class

class XWindow {
	XWindowImpl *pimpl; // since pointer fields don't require includes, there is no compilation 
	// dependencies on XWindowImpl.h
	// clients also dont depend on XWindowImpl
public:
	... // no change here
}

So no matter what we change in XWindowImpl.h, client won't have to recompile

"Window.cc"
#include "Window.h"
#include "XWindowImpl.h"

XWindow::XWindow(): pImpl{new XWindowImpl{}} {};
other methods: replace fields s, w, s, etc.
with pImpl->s, pImpl->w, pImpl->s, etc.

So if all the private fields are in XWindowImpl, then only the window.cc will need recompiling,
	if they change

Generalization:
 - What if there are several possible implementations?
 
 Eg:
 XWindows, YWindows
  - then the Impl structure can be a superclass

This is called Bridge Pattern

------------------------------------Measures of design quality--------------------------------------

 - coupling and cohesion // the main two ideas behing good design
 
Spectrum of the tightness of relationships between modules:
-----------------------------------------------------------
coupling: the degree to which distinct program modules depend on each other
	low: 
	 - modules interact via function calls with basic parameters and results
	low-medium:
	 - modules pass arrays/structs back and forth
	medium:
	 - modules affect each other's control flow
	medium-high:
	 - modules share global data // not great because you dont know what happens to the global data
	high:
	 - modules have access to each other's implementation (they are friends)

"I claim that if i want to, i can achieve perfect coupling, where coupling is 0"
// you can achieve that by putting everything into the same module
While you want to keep coupling down, you also want the cohesion, so simply using one file is not a 
solution in this case

Spectrum of cohesion between modules:
-------------------------------------
Cohesion: how closely elements of a module are related to each other
	low:
	 - arbitary grouping of unrelated elements (eg. <utility>) 
	low-medium:
	 - elements share a common theme, but otherwise unrelated; share some base code (eg. <algorithm>)
	medium:
	 - elements manipulate state over the lieftime of an object (eg. open/read/close files)
	 // related because they all help you to deal with files starting with open, ending with close
	medium-high:
	 - elements pass data to each other // implies that they call each other and one cannot exist 
	 // without another
	high:
	 - elements cooperate to perform exactly one task 

Idea is that:
 high coupling -> changes to one module require greater changes to other modules
 				- harder to reuse individual modules
 				
 low cohesion -> poorly orgaized code
 				- hard to understand and maintain

"I claim that i can also achieve perfect cohesion"
// you can do that by putting everything into its own modules

So the GOAL is lowest coupling and highest cohesion!

-------------------------------------Decoupling the interface (MVC)---------------------------------
"Your primary program classes should not be printing things"

No matter how tempting it might be, you should never write anything on the screen

Here is an example:
Suppose you are writing a Chess game

class ChessBoard{
	...
	...
	...
	cout << "Your move" << endl; // he is calling this bad design
}
this is bad design because it inhibits code reuse, this is an instance of coupling
// we coupled our ChessBoard to cout

What if you want to reuse the ChessBoard, but not communicate via stdout?
What if isntead, you want this thing going on a network and printing it there?

Not very convenient if you have this hardcoded into the class

one of the solutions is instead of printing to stdout, you provide class with stream objects, 
where it can simply send its output using those

then you will get a class like the following:
class ChessBoard {
	std::istream &in;
	std::ostream &out;	
public:
	ChessBoard (std::istream &in, std::ostream &out): in{in}, out{out} {....};
	....
	....
	out << "Your move" << endl; // now our class can print to files and not only stdin
	....
	....
}
This is definitely better, but its still not perfect. 
What if we don't want to use streams at all?
What if i want to implement graphical window now, instead of printing things to the screen?
You might also want to implement variety of languages so you need localization now

Your ChessBoard class should not be doing any communications at all

	Single responsibility principle:
	--------------------------------
	"A class should have only one reason to change"
	- game state and communications are two reasons // which is not good
	
So what would be better?
	if your chessBoard is not supposed to be speaking to the user, then someone else should do it
	but your chessboard should still be able to deliver messages to the user
	
BETTER - communicate with the ChessBoard via params/results
	- Confine user communication to outside the class
	
Q: who should do all the talking? should it be main() and then call chessboard methods?

A: No, hard to reuse code if its in main.
	should have a class class to manage interaction, that is separate from the game state class
	
---------------------------------Model-View-Controller Pattern--------------------------------------
Developed back in the day by Xerox

Idea is to separate the distinct notions of data (state), its presentation, and the control of the 
data

"Model": is the data (game state)
"View": is how the model is displayed
"Controller": how the model is manipulated

-------     ------
|Model|-----|View|
-------     ------
   \          /
    \        /
   ------------
   |Controller|
   ------------
// Damn this took a while

Model:
 - can have multiple views (eg. text+graphics)
 - doesn't need to know their details
 - classic observer pattern (or communicate through controller)
 
Controller:
 - mediates control flow through model and view
 - may encapsulate things like turn-taking, or may be responsible for the full set of game rules
 - may fetch input from the user (or this could be the view)
 
"By decoupling presentation and control, MVC promotes reuse" 
// should use this in your project because it will result in great design

"Now the technical part!!!"

------------------------------------------Exception safety------------------------------------------
Consider:
void f() {
	MyClass *p = new MyClass;
	myClass mp;
	
	g();
	delete p;
} // assuming this is not going to leak
// what if g() raises an exception

What is guaranteed when that happens?
 - During stack unwinding, all stack allocated data is cleaned up
 	- destructors run, memory reclaimed
 - so MC is cleaned up
 - HEAP allocated data is not freed tho
 - if g() throws, p is leaked
 
How to fix this function, so that it does not leak?

void f() {
	MyClass *p = new MyClass;
	MyClass mc;
	try {
		g();
	} catch (...) {
		delete p;
		throw;
	}
	delete p; // this is extremely UGLY and you also get DUPLICATED CODE
} // this is still not enough, because if g() does not throw, we still need to delete p

This is tedious, error-prone and causes duplication

So how else can we guarantee that something like delete p will happen no matter how we exit f()?
 - In some languages there are finally clauses, that guarantee final actions
 - C++ does not support those tho :(
 - the only thing you can count on in C++ is that destructors for stack allocated data will run
 - the point is that you should use the stack-allocated data with destructors as much as possible
 - use this guarantee that everything on the stack will be deleted to your advantage
 
C++ idiom: RAII - Resource Aquisition Is Initialization // final exam
 means that every resource should be wrapped in a stack allocated object, whose destructor deletes or
 frees it
 
One of the very first things that we saw in this class was an example of RAII
Eg: files

ifstream f {"name"}; // acquiring file is accomplished by initialization
// acquiring the resource {"name"} = initializing the object (f)
// the file is guaranteed to be released when f is popped off the stack (f's destructor runs)

Turns out you can do something very similar with dynamic memory!

What if everytime you allocate memory on the heap, you gave it to an object sitting on the stack
 so that it is destroyed every time its popped of the stack. This way you will NEVER LEAK
 
class std::unique_ptr<T>
 - takes in a T* in the constructor
 - the destructor will delete the pointer
 
void f() {
	auto p = std::make_unique<MyClass>(); // can write the type as std::unique_ptr<MyClass>
	MyClass mc;
	
	g();
} // this is guaranteed no leaks !!!

The difficulty with this system:
class C {...};

unique_ptr<C> p {new C{}}
uniqie_ptr<C> q = p; // this is potentially trouble

Now we have two unique pointers that are both pointing to the same thing and both of which will try
freeing when stack is deallocated, which will cause the program to crash

So how should we behave when we want a copy of the pointer, but dont want to delete twice?
 - C++ really doesn't want you to do that, so copying is disabled for unique_ptr
 - but the good news is that they can be MOVED!! // lol, turnup!

How do you return a smart pointer from a function if its going to be destroyed?
 - you move the smart pointer to your return value
 
wowoow, "At this point we have enough skill to write unique_ptr ourselves"

Sample implementation (check repository for more)

template <typename T> class unique_ptr {
	T *ptr;
public:
	unique_ptr(T *p): ptr{p} {}
	~unique_ptr() {delete ptr;}
	unique_ptr(const unique_ptr<T> &other) = delete; // disable copy constructor
	unique_ptr<T> &operator= (const unique_ptr<T> &other) = delete; // take the copy assignment away too
	unique_ptr(unique_ptr<T> &&other): ptr{other.ptr} {
		 other.ptr=nullptr;
	}
	unique_ptr<T> &operator= (unique_ptr<T> &&other) {
		 using std::swap;
		 swap(ptr, other.ptr);
		 return *this;
	}
	//these are supposed to act like pointers, so we have to add operator*,
	T &operator* () {
		return *ptr;
	}
	// in the repository you can also see the arrow operator
}

One big rule tho:
NEVER, EVER let the destructor emit an exception

Example:
Imagine that there is a baseball flying at you and you duck, but while you are ducking, you throw another
ball, which means that there are now two baseballs flying in somone else's face!
 - if the destructor was executed during stack unwinding dealing with another exception, then now you
   have two active, unhandled exceptions and the program will abort immidiately
 - this is a rule btw. Any time there are 2 unhandled exceptions, the program terminates no matter what!
   
MORAL: whatever you do in your life, whoever you become after completing DD and making it in this 
	rough world, where ever you end up on the map of our planet, just remember that you never throw in destructors
	
----------------------------------3 Levels of exception safety--------------------------------------

// remember these things word-by-word, shows up on the final  
1. Basic Guarantee - if an exception occurs, the program will be in a valid state - nothing leaked,
	 nothing corrupted, class invariants maintained
	 // says that the program is runnable, tells you that its in a valid state, but doesn't tell you
	 // what state its in tho
	 
2. Strong Guarantee - if an exception is raised while executing f(), the state of the program will be
	as it was before f() was called // exception will still happen tho
	// we now know that either f() never run, or that f() ran and completed successfully

3. No-throw Guarantee - an exception will not be thrown when running f(), but we also promise that 
	f() will actually accomplish its purpose
	
	
Suppose then:
class A {...};
class B {...};
class C {
	A a;
	B b;
	
	void f() {
		a.method1();
		b.method2();
	 } // we are told that both of these methods may trow, but they offer strong guarantee
};

Question is: Is C::f() exception safe?
A: let's go step-by-step and imagine what happens if: 
	- method1 throws:
		- it offers strong guarantee
		- so nothing happened yet, because the method didn't change anything
	- method2 throws
		- then method1 has already run
		- if we want to offer strong guarantee, we want to undo effects of method1 because method1
		  might have already executed by now
		
But how do you undo effects of one method? what if method1 printed something to the screen?
 - It is usually very hard or impossible to undo something if method1 has non-local side-effects

So the answer is "No, its not exception safe"

so if A::method1 one and B::method2 do not have non-local side-effects, then we can use a 
technique that we already know
 - We can use our good old friend of copy and swap
 - We make a copy, apply methods to it, if nothing was thrown, then we swap the copy for the original
 
class C {
	...
	void f() {
		A atemp = a; // could these throw?  
		B btemp = b; // yes, ofcourse
		// but the original a and b are still safe, so we are in the safezone
		
		temp.method1(); // if these throw, we are safe, because a and b are unchaged
		temp.method2();
		
		a = atemp; // if a throws, we are still good
		b = btemp; // if b throws, then its bad because a has changed already
	}
}

Why is this better?
 - if either one of the methods throw, then f is terminated, but the original a and b are the same
 - there is a fly in the ointment.. 
 	- what if copy assignment throws?
 	- it would be better if we used swap since it offers nothrow guarantee
 	
Solution, use the PIMPL idiom:
struct CImpl {
	A a;
	B b;
};

class C {
	unique_ptr<CImpl> Impl;
	....
	void f() {
		auto temp = make_unique<CImpl>(*pImpl); // new pimpl struct on the heap, copy of the old one
		temp->a.method1();
		temp->b.method2();
		std::swap(pImpl, temp); // no-throw guaranteed
	}
}

Rule of thumb for the future: If either A::method1() or B::method2() offer no exception safety guarantee, 
then neither can f()

---------------------------------Exception safety and the STL:vectors-------------------------------
What do we know about vectors?
 - vectors encapsulate a heap allocated array
 	- it complied with the RAII, where a stack allocated object manages the heap allocated data
 	- when a stack allocated object goes out of scope, the internal heap allocated array is freed
 	
void f() {
	vector <MyClass> v;
	....
	....
	// eventually v goes out of scope, at that point, the array is free and MyClass destructor runs
	// on all objects in the vector. Memory management? what is that? we balling out here!
}

BUT what if:
void g() {
	vector <MyClass*> v;
	...
	...
	// now if it goes out of scope, the array is freed, just like before, but there is something differen here
	// pointers don't have destructors, so this could be a potential memory leak, as any object
	// pointed to by a pointer are not freed, DAMN son, A4 in a nutshell
}

Vector is saying that i dont now who are the owners of those objects, i dont know if they are on the heap or stack
So I'm not going to delete it, you deal with them because you probably know more // if not - drop out
 - if vector does not own them, then it should not delete them, and its not a memory leak
 
but, if vector does own them, then do this:
	for (auto x:v) delete x;
	
But we were trying to get rid of all the explicit memory management tho..

Consider the following then:
void h() {
	vector<shared_ptr<MyClass>> v;
	...
	// and we are back to the happy place, where you dont have to delete anything
	// the array is freed, the shared pointer desructor is run only when all the objects stop pointing
	// at it. Once again, there is no explicit deallocation, which is magical
}

"Hopefully you are starting to see that you can write code without ever calling delete" // hint, A5

So should all of your vectors have shared pointers now? not really, think about the Observer pattern?
// if the vector does not own the objects, then you shold only delete the array, not the objects
// someone else will delete the objects because they have a different owner

--------------------------------------Shared Pointers-----------------------------------------------

If you really need to copy pointers and you can't distinguish an owner, there is an alternative:
 - std::shared_ptr
 
{ // opening up a scope 
auto p1 = std::make_shared<MyClass>();
	if (...) {
		auto p2 = p1; // so now we have a shared pointer, both of them pointing to the same thing
		// both have a destructor that will delete the object
	} // when we are at the end of this scope, the p2 is popped, but the pointer is not deleted
	
} // at the end of this scope, the p1 is popped and then the pointer is deleted

Shared pointers maintain reference count
 - count of all shared pointers pointing at the same object
 - memory is freed, only when the reference count hits 0
 
"If unique pointer was a game changer, this is an even bigger game changer"
"You pobably wondering what this racket stuff means here" 

(define l1 (cons 1 (cons 2 (cons 3 empty))))
(define l2 (cons 4 (rest l1)))

What is so speacial about these lists? 
they look like this: 
 1 - 2 - 3
 	/
   /
  4

Writing this in C++ is almost impossible, because you dont know who frees what and then you will have
a crapload of delete calls and they will crash your program

But now that we know about shared_ptr, we can do it, because they will delete automatically
 - this is almost the same as garbage collectors
 - garbage collectors don't do everything you need them to do (collect files and other things)
 - so C++ is the master race and is better than any other language with garbage collection
 
Use shared pointers as much as you can, it will dramatically reduce the number of memory leaks

Does that mean that you will never have raw pointers? 
 - no you still need them, but when you do use them, it means that they have no owner
 - noone will own it so noone will delete it
 - if 1 object owns it, then use unique_ptr
 - if 1+ object owns it, then use shared_ptr
 
"He is like: we are going to cover some of the most difficult material in the course, but it is all great"

----------------------------------------------Casting-----------------------------------------------
"A cast is a way to force an object to be treated as if it was a different type"

Eg:
Node n;
int *p = (int*)&n; // we are saying, force that to be treated like a pointer to an int

Casting is not usually a good idea, means that you are lying to a complier
As the saying goes: "If you lie to your compiler, it will have its revenge!!!"

C-style casts should be avoided in C++

but C++ also recognizes that sometimes you do actually have to do it
 - if you must cast, you a C++ cast style
 - C++ says that I know that casting is bad, so I will give you 4 different ways to do them:
 	// as we go through all of them, you will see how bad casting is and why having more types of 
 	// casting is actually better than having only one type.
 	- static_cast - "sensible" casts
 		Eg: casting double to int:
 		double d;
 		void f(int i);
 		void f(double i);
 		f (static_cast<int>(d));
		
		Eg: casting superclass pointer as a subclass pointer
		// going upwards, is easy, because of inheritance
		Book *b = new Text {...};
		Text *t = static_cast<Text*>(b); // we know its safe, because we are reverting from text
		// but we are still telling lies to the comiler
		What happens if that object is not a text? 
			-> Unpredicted behaviour
			-> we are hoping that compiler trusts us
			-> and we are taking all of the responsibility that b is actually pointing to a Text
		// hopefully you start to see the advantage to the C++ casting logic
		// if you do have a bug in your program, first thing that you want to do is check your casting
		// in other languages you will be searching for egrep "(type that you are casting to)", which will give you amilly of results 
		// in C++ you can simply egrep for "static_cast"
		// why we need 4 types of cast? because C cast might have more than one consequence of casting
		// wereas with 4 different types, casting is more precise
			
	- reinterpret_cast - for unsafe, implementation-specific, weird casts
		Eg: 
		Student s;
		Turtle *t = reinterpret_cast<Turtle*>(&s);\
		
		"You are only promised that if you cast and then cast back to the old type, you will get the same thing"
		// this is for "I know this makes no sense"
		// but I trust the compiler to do the right thing in this case
		
		"Reinterpret cast does not change the type of the existing objct"
		"Casting allows you to look at the object through a different lense"

		// there are some cool things that you can do with reinterpret_cast
		// you can create a similar class and reinterpret the original class as the new class
		// then, if your new class has identical private fields, but they are public now, you can reinterpret_cast it
		// into your class and get the value of provate fields. Educating potential hackers out here. 
		Here is a code Example:
		#include <iostream>
		using namespace std;

		class C {
  			int x;   // private
 		public:
  			explicit C(int xvalue): x(xvalue) {}

  			int getX() const { return x; }
		};

		class RogueC {
 			public:
  			int x;
		};

		int main() {
  			C c(10);

  			cout << c.getX() << endl;

  			RogueC *r = reinterpret_cast<RogueC*>(&c);

  			r->x = 20;

  			cout << c.getX() << endl;
		}

		
	- const_cast - for converting between const and non-const
		the only C++ cast that can cast away constants
		// it is not for changing constant variables, because those are stored in private memory
		
		Eg: you have a library function
		void g(int *p); // given to you
		
		void f(const int *p) {
			g(p); // this won't compile, because g might change the p
			// what if I happen to know that g does not change p, it was just the error in the signature
			// and you can't change it now
			// then you do this:
			g(const_cast<int*>(p));
		}
		
		const poisoning - The idea that as soon as you introduce const in one function, you will have
		to change all other fucntions to be const too
		// instead you can cast const, but its actually not a good idea, instead fix your const errors
		// and keep those constants in your life, after all anything can change any second, but the constants
		// will still be there. Its like the only object you can trust in the times of complete chaos
		
	- dynamic_cast - Is it safe to convert a Book* to a Text*?
		Book *pb;
		static_cast<Text*>(pb)->getTopic(); // is it safe?
		// depends on what pb actually points at
		
		Better to do a tentative cast // try and see if it succeeds
		
		Book *pb = _______;
		Text *pt=dynamic_cast<Text*>(pb);
		// if the cast works (pb really points at a Text, or at a subclass of Text) pt points that that object 
		// if the cast fails, pt will be a nullptr
		
		if (pt) cout << pt->getTopic() << endl;
		else cout << "Not a Text" << endl;
		
		
Now we want to know if we can do the same thing on smart pointers?
	- Yes, only the name of the functions is a little bit different
	- static_pointer_cast
	- const_pointer_cast
	- dynamic_pointer_cast
	- this is for casting shared_ptr to shared_ptr
	
Now we want to try to use dynamic_cast to make decisions cased on objects' RTTI (run-time type information)
	void whatIsIt (shared_ptr<Book>b) {
		if (dynamic_pointer_cast<Comic>(b)) cout << "Comic";
		else if (dynamic_pointer_cast<Text>(b)) cout << "Text";
		else cout << "Book";
	}
	This is legal, but this is generally not a good idea
	 - This is against the OOP
	 - in OOP you should aim at abstraction, where you don't care what subclass you are using
	 - everytime you make a new sublass, you will have to change your code
	 - this code is highly coupled to the book class hierarchy and causes bad design
	 
	 Better: use virtual methods or write a visitor
	 
Note: dynamic casting only works on classes with at least one virtual method
Note: dynamic cast also works with references
	Text t{...}
	Book &b = t;
	Text &t2 = dynamic_cast<Text&>(b);
	// if b points at a Text, t2 is a reference to same Text
	// what if it does not tho?
	// there is no such thing as null reference, so you get an exception
	
One example when dynamic casting is really useful:
 - with dynamic casting we can solve polymorhic assignment problem, that involves book, text, comic
 	I believe that it's about the assignment of the textbook to a book pointer. So if you remember the idea of slicing
	where you lose data. I guess here you won't lose it because the dynamic_cast will find that segment of book 
	inside the textbook and simply return a new pointer, and then you can always reverse the operation if you 
	have to by recasting again. Might be wrong tho
 - now we are going to write the mixed assignment operator!
 
Text &Text::operator=(const Book &other) {// virtual
	Text &textother = dynamic_cast<Text&>(other); // if it is not actually a Text, then we throw
	// make sure you catch in your caller
	
	if (this == &textother) return *this; 
	Book::operator=(other);
	topic = textother.topic;
	return *this;

-----------------------------------------How Virtual Methods Work-----------------------------------
Consider:
class Vec {
	int x, y;
public:
	int doSomething() {};
	....
}

class Vec2 {
	int x, y;
public:
	virtual int doSomething() {};
	....
}

What is the difference here?
 - not in terms of how they behave, but in terms of what they are?
 
Vec c {1, 2};
Vec2 w {1, 2};

Since they have the same fields, do they look the same in the memory?
We can check that!

cout << sizeof(v) << '' << sizeof(w) << endl;
-> 8 16 // so no, they dont have the same size
v = 8 bytes // space required to store 2 ints
// this also tells you that even though the methods are written inside a class, they are not stored
// there, so doSomething() is not stored inside a class. That would be foolish, its all about that memory efficiency
// So compiler turns methods into ordinary functions and stores them separately from objects
// this is also how you can insert functions into structures in C

Now let's recall what we know about our virtual methods...

Book * pb = new // either Book, Text, Comic

pb->isItHeavy();
// if isItHeavy is virtual => choice of which virtual is run is based on the type of the actual obj.
// this is easy to say, but you have to remember that this is not something a compiler knows
// but it still has to know it to call the right function

Since the compiler does not know before hand, which function to call, it has to figure it out at the
runtime. But how? // its up to the compiler how, there is no single way how all of them do it

But there is one method that is used the most tho:
 - For each class with virtual methods, the compiler creates a table of function pointers (the vtable)
 
Eg:
class C {
	int x, y;
	virtual void f();
	virtual void g();
	void h ();
	virtual ~C();
}

Vtable:
---------
| "C"   |
---------
|  f    |
---------
|  g    |
---------
|  ~C   |
---------
    ^
    |
C   |
---------
|   x   |
---------
|   y   |
---------
| vptr  |
---------

Objects of class C have an extra poitner (the vpointer) to C's variables

Book
----------
|title   |
----------
|author  |
----------
|numPages|
----------            -----------
| vptr   |----------->| "Book"  | // this field is there to support dynamic casting
----------            -----------      -----------------
                      |isItHeavy|----->|Book::isItHeavy|
                      -----------      -----------------
                                       | Blah Blah...  |
                                       -----------------
Text
----------
|title   |
----------
|author  |
----------
|numPages|
----------    
|topic   |
----------            -----------
| vptr   |----------->| "Text"  |
----------            -----------      -----------------
                      |isItHeavy|----->|Text::isItHeavy|
                      -----------      -----------------
                                       | Blah Blah...  |
                                       -----------------

So when calling virtual method
 - you follow the vpointer to the vtable
 - fetch pointer to actual method
 - follow the function's pointer + call the function

This is a reason why c++ does not make everything virtual. There are sunk costs associated with
chasing pointers to find which function to call
Also there is loss in space, because you want to store that vpointer every time you declare a virtual
method

Therefore the classes with non-virtual functions produce smaller objcts, then if one of the methods
is virtual 

this also explains how dynamic casting works
 - generally speaking the vtable will have information on what this object actually is
 - thats why he said that dynamic casting works on classes with atleast one vitual method
 - this also means that dynamic casting can be very expensice // static is cheap tho

Now lets look how these objects look in the memory:
 - this is compiler-dependent
 
g++:
----------
|vptr    |
----------
|field1  |
----------
|field2  |
----------    
|field3  |
----------

Why does the vpoitner come first? He says it has some kind of advantage...

class A {
	int a, c;
	virtual void f();
}

----------
|vptr    |
----------
|a       |
----------
|c       |
---------- 

class B: public A {
	int b, d;
}

----------
|vptr    |
----------
|a       |
----------
|c       |
---------- 
|b       |
----------
|d       |
----------

Because of the inheritance: 
 - So that pointer to "b" looks like a pointer to "a" without the last two fields

"We are now about to discuss what is perhaps the most feared topic in all of C++"
 - very few languages actually to this
 - the idea that a class can inherit from more than from one class 

class A {
public:
	int a;
};

class B {
public:
	int b;
};

class C: public A, public B {
public
	void f() {
		cout << a << '' << b << endl;
	}
};

// what we had on A4 and what we see here is pretty straight forward, but there are some challenges
// in the more advanced world

Suppose:
	- B is inheriting from A
	- C is inheriting from A
	
	class D: public B, public C {
	public:
		int d;
	};

	D dobj;
	dobj.a; // how do you know which a to get, since you have two a's one that is inherited by b
	// and one that is inherited by c
	
	You will get compilation errors if you try to compile it
	// to fix it you to have indicate which one you need
	cout << d.B::a << endl;
	
But you may ask if that is even the right thing to do.. 
Example:
 - you have a base class vehicle:
 - vehicles have a steering wheels, seats, dash panels, engines
 - there are sea vehicles and land vehicles
 - but if you go to a tourist town, there are sometimes amphibious vehicles
 - imagine the inheritance for that, it will be both a land and a sea vehicles
 - does that mean that the amphibious vehicles have two steering wheels? two seats? two engines?
 
So if B + C both inherit form A, should there be one A part of D, or two? // two is default
 - should B::a and C::a be the same or different?
 - what if we want that B and C are both inheriting from the exact same A
 - it has a name in C++ circles "The deadly diamond"
 - it has another name "The deadly diamond of death"
 
If you want there to be one object at the top of the diamond instead of two, you have to make A a 
virtual superclass. A.k.a. you are "employing virtual inheritance"

class B::virtual public A {...}
class C::virtual public A {...}

This is what will give you a diamond pattern

"this is something we have been using all along"

best example of this is the I/O steam hierarchy

ios_base is at the top
 - ios inherits from ios_base
 - istream inherits virtual ios
 - ostream inherits virtual ios
 - istringstream inherits from istream
 - ifstream inherits from istream
 - iostream inherits from istream and ostream
 - ostreingstream inherits from ostream
 - ofstream inherits from ostream
 - fstream inherits from iostream
 - stringstream inherits from iostream
 
How will thw diamond of death pattern be laid out in vtable tho?

----------
|vptr    |
----------
|A Fields|
----------
|B Fields|
---------- 
|C Fields|
----------
|D Fields|
----------

this wont really work tho.. if we have a pointer pointing at the top of the table:
 - it might look like an A object, B object, maybe even D object
 - but it will never look like a C object
 - C inherits directly from A, so C should come after A
 - and we can't rearrange C and B because then B won't look like it should
 
If we are stuck, we can definitely ask g++ on what it does.. 
// g++ is should be your best and only friend in this world. You are going to live cs, breathe cs, eat cs, and do cs all your life

Damn, listen what happens next tho..

To see what is inside D, we are going to turn the D pointer into an array and simply print every item
in it... This way we will show what is in D's memory

4198496
0
200
0
4198536
0
300
400
4198576
100

// since the longer numbers are pointers, because they bigger than ints

----------
|vptr    | // assume that this is to B
----------
|B Fields|
----------
|vptr    | // assume that this is to C
---------- 
|C Fields|
----------
|D Fields|
----------
|vptr    | // assume that this is to A
----------
|A Fields|
----------

You have to understand that B inherits from A, it does not know about C or D, so B should be like this:
----------
|vptr    |
----------
|B Fields|
----------
|vptr    |
---------- 
|A Fields|
----------

One thing we learned today is that "the distance from B to its superlcass part A is not always the same"
// the offset by which B is away from A is stored in the vtable

- location of the superclass is stored in the Vtable
- Diagram does not look like A,B,C,D silmuntaneously, but slices of it do look like A,B,C,D

D d;
A *a = &d; // assigning shifts the data to make it look like an A

=> pointer assignment among A,B,C,D changes the address stored in the pointer, so that it is
	pointing at the right spot, so will the casting operations
	- static/const/dynamic cast under multi-inheritace also change the value of the pointer
	- reinterpret_cast does not tho.. because we really want something to look like something else
	
// example from lecture is in vtable folder

------------------------------------Template Functions----------------------------------------------

template <typename T> T min (T x, T y) {
	return x<y?x:y;
}

int x = 1, y = 2;
int z = min(x,y); // notice that we are just going ahead and calling it
	when we are calling a template class, we have to specify what type it is going to be..
	- dont have to do that with template functions tho, because C++ can infer that from the arguments
		that are being passed to the function
	- sometimes, C++ might not be able to guess the values by itself, so you can always tell it
	min<int>(x, y);
	
So we can do things like the following:
char w = min('a', 'c'); // T = char
auto f = min(1.0, 3.0); // T = float

We might now ask, for what types of T does it work?
The rule is to think:
 - for what types of T will the body compile
 - any type that has a less than operation supported
 
void for_each(AbstractIterator start, AbstractIterator finish, int(*f)(int)) {
	while (start != finish) {
		f(*start);
		++ start;
	}
} // the idea is that as long as you provide an iterator to your class, we can iterate over any object
// a class, a list, a vector...

Now think, what does start and finish do here, do we really have abstraction?
We will have abstraction if this happens:
- Works as long as AbstractIterator supports !=, *, ++
- f can be called as a function
- we want to make these tow arguments above templates

template<typename Iter, typename Func>
	void for_each(Iter start, Iter finish, Func f) {
		while (start != finish) {
			f(*start);
			++ start;
		}
	} // the advatage now is that Iter can be any type supporting !=, ++, *
	
There is one type that we are familiar with, and support these three operations, but is not a class:
	- raw pointers
	
void f(int n) {
	cout << n << endl;
}

int a[] = {1, 2, 3, 4, 5};

for_each(a, a+5, f); // this will print an array
// recall: when you call an array by name, it gives a pointer to the first argument

This opens up some possibilities for us that are available in the default library
- there is a header called <algorithm>
- full of template functions, many of which work over iterators
- Examples:
	- for_each (as given above)
	- template<typename Iter, typename T> 
		Iter find(Iter first, Iter last, const T&val) {
			// returns itertor to the item that you are looking for
			// if nothing found, it returns last
		}
	- count, which is like find, but instead it returns the # of occurences of val
	- template<typename InIter, typename OutIter> 
		OutIter copy(InIter first, InIter last, OutIter result) {
			// copies one container range from one class to another, starting at result
			// Note: does not allocate new memory
			// for this to be valid, you have to know that the other container has enough space
			// container types dont have to be the same
			// can copy from a vector to a list
		}
		
		vector<int> v {1, 2, 3, 4, 5, 6, 7};
		vector<int> w(4); // space for 4 ints
		
		copy(v.begin() + 1, v.begin() + 5, w.begin()); // w = {2, 3, 4, 5}
		
	- template<typename InIter, typename OutIter, typename Func> 
		OutIter transform(InIter first, InIter last, OutIter result, Func f) {
			while (first != last) {
				*result = f(*first);
				++first;
				++result;
			}
			return result;
		}
		Eg:
		int add1(int n) {return n + 1;}
		vector<int> v {2, 3, 4, 5, 7, 11};
		vector<int> w(v.size());
		tranform(v,begin(), v.end(), w.begin(), add1);
		// w = {3, 4, 6, 8, 12}
		
		Q: Just how general is this?
		Q2: what can we use for Function? 
		Q3: what can we use for InIter and OutIter?
		1) Func. How is f used? f(*first)
			- f can be anything that can be called as a function..
			// but we can write operator() for objects.
			Eg:
			class Plus1{
				public:
				int operator() (int n) {return n + 1;}
			}
			
			Now we get this behaviour:
			Plus1 p;
			p(4); // produces 5
			// HOly jesus.. wtf is going on? Why does he have to reveal this on the last day of class
			
			tranform(v.begin(), v.end(), w.begin, Plus1()) // Plus1() is a constructor call
			
			Generalize:
			class Plus {
				int m;
			public:
				Plus(int m): m{m} {}
				int operator() (int n) { return n + m; } 
			};
			
			Now we can do the following:
			tranform(v.begin(), v.end(), w.begin(), Plus{1}); // this should look awfully similar to
			// to what we saw in 135
			
			Plus1, Plus - called function objects
				Advantage of having an object over functions, objects can remember things, they can
				maintain state. Now lets consider something a little bit more exotic
				
			class IncreasingPlus{
				int m = 0;
			public:
				int operator() (int n) { return n + (m++); }
				void reset() { m = 0; }
			};
			
			vector<int> v(5, 0);
			vecotr<int> w(v.size());
			tranform(v.begin(), v.end(), w.begin(), IncreasingPlus());
			// w = {0, 1, 2, 3, 4}
			This is hard to do with a function, but its easy to do with an object
			
			Q: How many ints in a vector v are even?
			vector<int> v{....};
			bool even(int n) { return n % 2 == 0; }
			
			A: int x = count_if(v.begin(), v.end(), even);
			
			// people resist using these functions because you always have to write your own in loop
			// comparision functions.. like the function we just wrote even for example
			
			Seems like a waste to explicitly create function even.
			If this were Racket, we would use lambda.
			
			C++ finally decided to add that too:
			// wtf is going on? wtf is going on? wtf is going on? wtf is going on? wtf is going on? 
			// wtf is going on? wtf is going on? wtf is going on? wtf is going on? wtf is going on?
			// alright back to coding tho..
			
			int x = count_if(v.begin(), v.end(), [](int n){return n%2 == 0;});
			// there are things that go into the square brackets, but we are not going to cover that
			// C++ lambda is so much dumber than the Racket lambda..
			// But you can do simple things and its enough to encourage the use of algorithm library
			// So C++ is magical amazing land now..?
			
			You might ask what is the type of a lambda function?
				- it was a type, but its a secret
				- compiler makes up a type, but never lets you know
				- if you want to store a lambda in a variable then you can't
				- unless you use auto // revolutionary
				
				auto even = [](int n){ return n%2==0; }
				
				What if you want to pass even to a function?
				int f(declType(even) x) {...} // declType(even) matches even's type
				
		2) what about Iterators? how generalized are those?
			Iterators - apply the notion of iteration to other data sources
			eg: streams... 
			
			#include <iterator>
			
			vector<int> v{1, 2, 3, 4, 5};
			ostream_iterator<int> out{cout, ", "};
			copy(v.begin(), v.end(), out); // Prints 1, 2, 3, 4, 5,
			// if you don't want the delimeter on the last one, stop one earlier and print last one
			// yourself
			
			vector<int> v {1, 2, 3, 4, 5};
			vector<int> w;
			
			copy (v.begin(), v.end(), w.begin()); // this is WRONG because copy does not allocate space
			
			Remember: 
			 - copy doesn't allocate space in w.
			 - it can't - it doesn't even know that w is iterating over a vector
			 
			But what if we had an iterator whose assignment operator does manage to somehow allocate
			space?
			
			Then we could do this: 
			copy(v.begin(), v.end(), back_inserter(w));
			// this copies v into w and allocates space if neccessary
			
			// Wow, its over.

