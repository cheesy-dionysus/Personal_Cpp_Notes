-------------------Pattern matching in text files-------------------

	egrep (extended global regular expression print)

	Usecase: egrep pattern file - prints every line in the file that is matching 		   the pattern

eg: print every line in the file index.html that contains cs246 
--> egrep cs246 index.html // pattern = cs246

how many lines in index.html contaij cs 246?
--> egrep "cs246|cs 246" index.html | wc -l // find the pattern, then pipe output of egrep to wc (-l gives the number of lines) to get number of occurences

OR 

--> egrep '(cs|CS) 246' index.html | wc -l // allows to search for both “cs246” and “cs246”

available patterns called regular expressions, different from globbing patterns

"[cC][sS] 246" [] means to look for any one char between [ and ] 
               [^...] means to look for any one character except ... 

Now try adding an optional space: 
"[cC][sS] ?246" 
	? = 0 or 1 or preceding expressions // so we are looking for:
		“cs(0 or 1 space 	characters)246”
	
Now what if you want to leave multiple spaces?
	* = 0 or more of preceding  spaces. notice that its different from globbing
“cs( )*246” // we are looking for “cs(0 or more space character)246”

Similar example: 
"(cs)*246" // we are looking for “(0 or more occurences of “cs”)246”
Possible results -> 246, cs246, cscs246, 

Next regular expression is a . (dot) matches any single character
	.* then means anything at all // we are saying 0 or more occurances of any 		character, which imples, find everything 

"cs.*246"
Possible results -> lines containing cs(anything in between)246

Always remember that egrep gives you lines that contain the pattern, not number of occurences

More regular expressions

^,$ - beginning and end of a line. //begin matching exactly with the characters 	after ^(chars)
	// match line that ends with character before (chars)$

"^cs246" // lines that start with cs246

"^cs246$" // lines that are exactly like cs246

last regular expression is:
.+ // 1 or more ocurences of preceding pattern

.+ gives you anything non-empty // looking for any one character occuring atleast 	once. Means we are looking for non-empty

eg: We are looking for lines of even length

(..)* this gives you even lines, but 0 is even too. so you have to fix it with "^(..)*$" which means that it will have atleast 2 in length.
	// the two dots in brackets mean any two characters, so its either 2,4,6..

List files in current directory with names containing exatly one a 

ls | egrep "^[^a]*a[^a]*$" // start with 0 or more occurences of not a
	// then look for 0 or more occurences of a with no a after it

Look for all words in the global dictionary that start with e and have 5 characters 

egrep "^e....$" /usr/share/dict/words // starts with e and .... means any 4 other 	characters after e

-------------------------------Permissions-------------------------------

	new flag for “ls” command. ls -l gives the long form listing

eg:
-rw-r----- 1 j2smith j2smith 25 Sep 9 15:37 abc.txt

Char 1:
type - what kind of file is it.
	// - an ordinary file. 
	// d is a directory 

Next 9 characters are permissions, 3 groups of 3 bits 
	1st 3 are user bit (file owner)
	2nd 3 are group bits 
	3rd 3 are the other bits (for all other people)
they tell you what each class of user can do to a file or directory

Next we have # of links:
	owner - user that owns the file
	groups - grops is how linux allows file sharing. a user can belong to 1+ 				groups 
             - a single file can be associated with one group

Then we have:
	size - file size in bytes
	last modified - last modified timestamp
	name - filename

Q: What would happen if you are inside a directory where you have r bit disabled? 
A: its like being in a dark room. if you know what is in the directory, you can get 	to it, if you dont, you can only try guessing

A: On the other hand, if the directory bit is not set it is like a brick wall.
Means that you have no acces to the directory nor to any file or subdirectory.

Now consider changing permissions 

command: chmod [mode] [file] 
// mode is u for user
	     g for group
	     o for other
	     a for all,
		 
// + to add permission
   - to remove permission
   = to set permission
 
eg: if you want to give everyone permission to read file
--> chmod o+r [file]

if you want to make everyones permission read and execute 
--> chmod a=rx [file] // need equal because someone might already have write permission and you want to take that away from them

what if you want to give a user full control? 
--> chmod u=rwx [file] // or u+rwx file
// file/directory owner can always change the permissions so can root


-----------------------------Shell scripts-------------------------------------
	// files containing sequences of shell commands executed as programs

eg: we want to print date, current user, current dir
#!/bin/bash // this is called “shebang line” needed to tell bash where to look for 		// our code
date
whoami
pwd

to execute, you have to type ./myscript in command line 
// here we are saying that bash should look in ./  (current) directory for script

since we are talking about programming, you can set variables here too:

eg: x=1 
// in variable declaration, no spaces are allowed. Because then, the shell will think that you are running a command called 'x', with args “=” and “1”)

Now getting value of a variable:
eg:
echo x
// will not work, because it will simply return 'x', you have to use something to tell echo to fetch the x value

Instead, we should use:
eg:
echo $x

Notes:
* Use $ when fetching the value of a variable, No dollar sign when setting a variable tho.		 
* Good practice: ${x} might change things occasionaly when you dont know where the variable name ends. For example ${file}.in is different from $file.in
* Finally, all shell varibales are Strings



eg: 
dir=~/cs246
echo ${dir}

Output:
/u3/username/cs246
	
There are also come global variables that are always available to you:
eg:
${PATH} // a list of dirs separated by colons. 

Reason why shell could't find your script earlier (when you run without “./”)is because it has a set list of dirs to look for programs that you are trying to run.
When you type a command, shell searches these directories in order to find a program with that name

There is a difference here too:
	* echo "$PATH" --> expands // “” returns value of $PATH
	* echo '$PATH' --> doesn't expand // '' returns var name PATH

Special variables for Scripts:
	$1, $2, $3 .... $n 
// these values represent command line argumens that you pass to your script
	
eg: Check wether a word is in the dictionary (./isitaword hello)
	#/!bin/bash
	egrep "^$1$" /usr/share/dict/words
	
eg: a good password should not be found in a dictionary. check whether a word is a good password
	#!/bin/bash
	egrep "^$1$" /usr/share/dict/words > /dev/null 
// now we don't want egrep to print anything, so we redirect output to /dev/null. It's like a black hole where you can redirect all the output to dismiss it

// Note: every program returns a status code, when finished. In case of egrep, the status codes are 0 if found 1+ matches and 1 if not found. (And thats a general convention: 0 = success, !0 = failure)
							   
// Usually, 1 is an expected failure, and larger numbers represent more serious failures

“$?” is the status of the most resently executed command

Now, if statements:

if [ $? -eq 0 ]; then 

// Be very careful with spacing. What it does is runs a command and checks for 	success.
// “[“ is the name of a program and other things are the arguments. 
// “;” is needed to separate commands, otherwise you'd have to put “then” on the 	next line

	echo “Bad Password”
	else
	echo “Maybe a good password”
fi

eg: now we want to be more careful about the input and verify arguments. Print error messge if something is wrong

#!/bin/bash
usage () {
	echo "Usage: $0 password" >&2 
	// “$0” is the command itself “>&2” means redirection of output to the stderr
	}
	if [ $# -ne 1 ]; then // $# - number of arguments
	    usage // calling function usage()
	    exit 1 // exit with expected error
	fi // closing if statement
	.... as before ....

In general, the if statemnt looks like this:
	if [ cond ]; then
		-
		-
		-
	elif [ cond ]; then // many more conditions are available on the handout
		-
		-
		-
	else 
		-
		-
		-
	fi 

------------------------------Loops------------------------
	
	WHILE LOOP:
eg: print numbers from 1 to $1
    #!/bin/bash
    x=1
    while [ $x -le $1 ]; do
    echo $x
    x=$((x+1)) // this wont work x=$x+1, because $x is a string and you will get "1+1"
    done

Though, most of the time we are going to be looping over a list of files, so we need a different kind of loop
	
	FOR LOOP:
eg: you want to remame all .cpp files in pwd to .cc
    #!/bin/bash
    for name in *.cpp; do // *.cpp is a glob that finds all matching files
    mv ${name} ${name%cpp}cc // "${name%cpp}" is the value of name without the trailing cpp
    done
		
eg: how many times does the word $1 appear in the file $2
    #!/bin/bash
    x=0
    for word in $(cat $2); do
    if [ "$word" = "$1" ]; then // because we are not comparing strings, we are using =, for numbers use -eq
	x=$((x+1))
	fi
    done
	echo ${x}
	
eg: Payday is the last friday of the month. When is this month's payday?
    2 tasks: compute date, report answer
	#!/bin/bash
	answer () {
	  if [ $1 -eq 31 ]; then // inside a function $1, $2 ... $n are the arguments of a function
	  echo "This month: the 31st"
	  else
	  echo "This month: the ${1}th"
	  fi
    }
	answer $(cal | egrep "[0-9]" | awk '{print $6}' | tail -1)  
	    
Generalize to any month, but if you dont give a specific month to the program, it will work the old way
	#!/bin/bash
	answer () { 
	  if [ $2 ]; then 
      	preamble = $2
      else
      	preamble = "This month"
      fi

	  if [ $1 -eq 31 ];
      	echo "${preamble} the 31st"
      else
      	echo "${preamble}: the ${1}th"
      fi
    }
	answer $(cal $1 $2 | awk '{print $6}' | egrep "[0-9]" | tail -1) $1 // $1 is the month, if there is no month and a year, then $1 and $2 are blank, nad we get the old behaviour

---------------------------Testing--------------------------
	essential part of program development
	
Machine testing
	- run program on selected input check against spec
	- can't always check everything, so you have to check your test cases carefully

Black box - tester has no knowledge or access to the internal workings of a program
Grey box - tester has limited knowledge of the internal details of the program
White box - tester uses program's source code as basis for designing tests
	
So we always start with black box, and then add white box tests 

Various classes of input
	- numeric inputs
	- positive vs negative
Boundaries of valid ranges (very important)
	- edge cases
	- multiple edge cases silmuntaneous (corner cases) 
Intuition/Experience will allow for better tests, because you will have understanding of where code usually breaks
Extreme cases (maximum difficult variables)
White box tests - execute all logical paths through the program (Coverage)
	- make sure all your functions get called atleast once
	- make sureevery single line of your code has been used
Performance testing - is the program efficient enough?
Regression testing - sometimes you fix one thing, but then break something else. Have to look out for those
	- thats why we use test suites, testing scripts, this way we can keep adding tests until we cover everything


----------------------C++--------------------------
	We will learn c++14

	Start with what we know, so in C
	
Hello World in C:
	
#include <stdio.h>
int main() {
  printf("Hello World\n");
}

Hello World in C++
	
#include <iostream> // stdio.h printf is still available here, but preffered to use header <iostream>
using namespace std; // lets you say cout/endl instead of std::cout/std::endl			   	

int main() { // main must return int in C++
  cout <<"Hello World"<<endl;
  return 0; // this is a very good practice to return something at the end. Technically we do say that main() returns int.
}

How to compile C++ programs?
-> g++-5 -std=c++14 program/cc -o program // "-o program" name of created executable, by default: a.out

Since we did aliases to out profile in a0, we can write compilation command in a much shorter form:
-> g++14 program.cc -o program
and to run your program, type: 
-> ./program

printf and other c code is banned in this course, always use c++ functions, methods, expressions, etc..

-----------C++ I/O streams-----------------

C++ gives you 3 i/o streams
	- cin for reading from stdin
	- cout, cerr for printing to stdout and stderr

I/O operators: 
	<< means "put to" for output
	>> means "get from" for input

So you can do code like this: 
	cerr << x; - information is flowing from x to cerr
	cin >> x; - information is flowing from cin to x 

Arrows show where the information is flowing and its direction

eg: add two numbers

#include <iostream>
using namespace std;

int main() {
  int x, y;
  cin >> x >> y;
  cout << x + y << endl;
  return 0;
}

cin operator ignores whitespace 
 - if input doesn't contain numbers, cin fails and var is undefined
 - if input is exhausted before we give 2 ints, we press ^d (EOF) then the statement fails and var is again undefined
 - if read fails, there is an expression cin.fail() which will always be true when read fails
 - if you get EOF, then cin.eof() and cin.fail() will both be true // However, these won't turn on, until you try to read file and fail

eg: read all ints from stdin, echo them one per line to stdout, stop on any failure

*********v1.0 of example***************
int main() {
  int i;
  while (true) {
  cin >> i;

  if (cin.fail()) break;

  cout << i << endl;
  }
}

there is an "implicit conversion" (remember this word) from cin or cout to bool, which means you can use cin as a condition
 - so cin is true if successful and false if failed

********v2.0 of example*********** 
int main() { 
  int i;
  while (true) { 
    cin >> i;

    if (!cin) break;

    cout << i << endl;
  }
}

Now a little bit more details about >> << operators
 - >> this is C's right bitshift operator. a >> b shifts a's bits to the right y b spots

eg: 
	21 >> 3 
	we know that 21 = 10101 
	So 21 >> 3 = 01 >> 11 = 10
this means the same in C++, cin moves a bits to b, hence "get from"

operator >> : 
 - has inputs cin on the left (istream) and data on the right (variety of inputs)
 - output? - returns another cin (istream)
 - this is why you can write cin >> x >> y >> z; 

*********v3.0 of example **************
int main() { 
  int i;
  while (true) {
  if (!(cin >> i)) break;
  cout << i << endl;
  }
}
  

********v4.0 of example ***********
int main() { 
  int i;
  while (cin >> i) { 
    cout << i << endl;
  }
}

eg: read ints and echo to stdout until eof, skip all non-int input

int main() {
  int i;
  while (true) {
	if (!(cin >> i)) {
	  if (cin.eof()) break;
	  cin.clear(); // clears the fail bit. But the wrong character is still in the stdin.
	  cin.ignore(); // means to skip the next character
	}
	else cout << i << endl;
  }
}

------------------------Reading Strings------------------------

c++ has a type std::string, which you get by #include <string>

int main() {
  string s;
  cin >> s; // skip leading whitespaces and stop at the next whitespace (reads one word)
  cout << s << endl
}

if you do actually want to read the whitespaces, use: getline(cin, s)
 - reads form current position to new line into s

Examples:
	cout << 95 << endl; // will print 95 to the screen now if you want to show the value in hexadecimal.
	In C you have to use %x with printf, but there is no printf in c++

So we use this instead:
	cout << hex << 95 << endl; // prints 5f, which is 95 in hexadecimal
	hex - is an io manipulator. It works in a way, that from now on, all subsequent ints are printed in hex
	
if you want to print only one in hex, use "dec" to go back to decimal. (There are many manipulators that are available to us. You can find those in the printed notes)
	many of the manipulators will require to use #include <iomanip>

Stream abstraction applies to other sources of data. For example, files
 - You may want to read from a file, rather than stdin
 - std::ifstream - read from a file
 - std::ofstream - write to a file
	
-----------------------File access in C----------------------------

int main () {
 char s [256];
 FILE *file = fopen ("myfile.txt", "r");
	
 while (true) {
    fscanf(file, "%255s", s);
	if (feof(file)) break;
	printf ("%s\n", s)
  }
  fclose(file); // awlays have to close the file
}


----------------------Now file access in C++------------------------

#include <iostream>
#include <fstream>
#include <string>
using namespace std;

int main() {
  ifstream file {"myfile.txt"}; // shit in the curly brackets is initialization syntax. Declaring the ifstream, opens the file.
  // We will see this notation later again
  string s; // string is now a type and they manage their own size, not like C

  while (file >> s) { // this will only read a word at a time, use getline(file, s) to read a line
	count << s << endl;
  }
// no fclose(), the file is closed automatically, as soon as ifstream goes out of scope
}

Anything you can do with cin and cout, you can also do with an ifstream and ofstream

Example:
 - strings: attach stream to a string variable and read from/write to it
 - the include for stream string is #include <sstream>
 - types are std::ostringstream, std:istringstream 

Imagine you have two ints lo=xxxx, hi=yyyy and you want to use them to print a string:
	ostringstream ss; // create a string stream variable
	ss << Enter a # between " << lo << "and" << hi; // you first fill in the stream
	string s = ss.str(); // then you turn the stream into a string

eg: Convert string into #
int main() {
  int n;

  while (true) {
	cout << "Enter a # " << endl
	string s;
	cin >> s;
	
	istringstram ss {s}; // shit in {} is initialization
	// you first read in a string, then turn it into a stream

	if (ss >> n) break; // check if you got an integer out of the stream
	
	cout << "I said, "; // if no ints, keep reading
  }
  cout << "You entered " << n << endl;	
}

EXAMPLE revisited: read in #s, skip non-ints

int main() {
  string s;
  int n;

  while (cin >> s) { // the only way reading a string can fail, is if you have EOF
	istringstram ss {s}; // you put the input into a string stream
	if (ss >> n) cout << n << endl; // then you try to get out an int from the stream
  }	
}

Behaviour is slightly differnt tho, try printing "a1s2d3f4" with both functions

--------------------------Strings------------------------

in C strings are char* or char[] terminated by \0
 - you must explicitly manage memory
 - you must allocate more, as strings get larger
 - very easy to overwrite that trailing "\0" and corrupt your memory

in C++ strings
 - grow as needed, no need to manage memory
 - safer to manipulate, because they don't depend on the "\0"

eg (Very important to understand):
	
string s = "hello"; // "hello" is still a C style string with chars |h|e|l|l|o| 
// s is a C++ string created from C string upon initialization
// this is needed for the backwards compatibility with C
// this works because of implicit type conversion

C++ String operations:	
 - Equality: s1 == s2, s1 != s2
 - Comparison: s1 <= s2 (lexicographic)
 - Get invidual characters: s[0], s[1] ... s[n]
 - Concat: s3=s1+s2; s3+=s4;
 - Length: s.length()

* more details are in the printed notes


		Default f'n params:

void printWordInFile (string name="suite.txt") { // passing a default parameter 
  // name can be passed when we call function, but it is not passed, a default value is used
  ifstream file {name};
  string s;
  while (file >> s) cout << s << endl;
}

Now you can call: 
printWordsInFile("test.txt")
Or say printWordsInFile() // and it will use default value
IMPORTANT: optional parameters must always come last 
	 imagine you have a f(int k=5, int n) // if you call f(5) the compiler won't know wif n is 5 or if k is 5


		Overloading:
c: 
int negInt(int n) {return -n;}
bool negBool(bool b) {return !b;} 

c++: Functions with different parameter names, can share the same name
int neg(int n) {return -n;}
bool neg(bool b) {return !b;}

The act of doing this, is called overloading. 
	Now when you call a function by its name, how does the compiler know which one, you meant?
	 - compiler, uses the number and type of the arguments to decide which name is being called. So overload must differ in # of args or types of args
	 - may not simply have different return types

------------------Structs----------------------
	
struct Node {
  int data;
  Node *next; // in c++ you dont have to mention that Node is a struct
};

struct Node {
  int data;
  Node next; // what is wrong with this? -> We have a node inside of a node. You would not be able to tell the size of this stucture
};

-------------------------Constants------------------------
Constants: const int maxGrade = 100; //must be initialized, you should be using it as much as you can
	
Node n1 = {5, nullptr}; // sytax for null pointer. Null is not a built in variable in c or c++
// null usually is a number = 0, But that could be a problem because you want to use a null for a pointer and it will give you a number, not a pointer
// thats why c++ came up with nullptr so that you dont have to use null for pointers
	
const Node n2 = n1; // this is an immutable copy of n1, means that you can't change n2's fields

----------------------Parameter Passing------------------

Recall the following from 136: 
void inc (int n) {++n;}
...
int x = 5;
inc(x);
cout << x << endl; // still prints 5
// example of call by value, where inc() gets a copy of x, increments the copy and the original is unchanged.
	
// if you would like to inc to be able to modify the x, you want to pass the pointer to the value, rather than a copy
void inc (int *n) {(*n)++;}
...
int x = 5;
inc(&x); // using x's address, rather than the value
cout << x << endl; // prints 6 	 

Q: Why do we say cin >> x and not cin >> &x?
A: C++ has another pointer like type, they are called references

-------------------------References-------------------------- 
					(VERY IMPORTANT)

	int y = 10;
	int &z = y; // im saying, z is an lvalue reference to y
				// like a const pointer, similar to a declaration like:
				// int *const z = &y (not exactly the same tho)

	References are like constant pointers with automatic dereferencing
	
	z[]---->y[10] // z is pointing to the memory location of y and can't be changed

	z = 10; (not *z=10;) // and we get that y == 10

	int *p = &z; // trying to take the address of z, but when you do it, it gives you the address of y
				 // so in all cases z behaves exactly like y, they really should be indistinguishable

	we can say z is an alias ("another name") for y
	
	Rules for referencing: "Things you cant do with lvalue references" 
	1. Can not leave them uninitialized //eg: int &x;
	2. Must initialize to something that has an address // "something that has an address" is called lvalue - the thing on the left of the assignement value
		// eg: int &x = 3; bad
		// eg: int &x = y + z; bad 
		// eg: &x = y; good
	3. Cannot create a pointer to a reference: int &*x; bad // always start with the variable and work your way up
		But, perfectly legal to create reference to a pointer: int *&x= ____; good
	4. Cannot create a reference to a reference:
		int &&x=___; // this means something different (covered later)
	5. Cannot create arrays of references: 
		int &r[3]= {n,n,n}; bad

	Rules: "Things you can do"
	1. Pass references as function parameters. 
		void inc (int &n) {++n;} // &n is a constant pointer to the argument. 
								 // Notice: no pointer dereference, and printing passed value later will give you incremented value

	Q: So why does cin >> x works? 
	A: Because the operator that you are using takes x by reference

	Now we can discuss the exact signature of an input operator:
	istream &operator>> (istream &in, int &data) // why use references? because rather than using call by value, where you take a copy. It is not allowed to copy streams, 
												  // also means you can't pass it by value, can only pass by reference	
	Pass by value. eg: int f (int n) {...} // copies the argument
	-- If the file is very large, then the copy can be expensive 
	
	eg: struct ReallyBig {....}; // if you create a pass by value function on that.
		int f (ReallyBig rb) {...}; // to avoid copying, you can pass it by reference
		int g (ReallyBig &rg) {....}; // since i didn't do any copying, this thing is fast
	"Downside: i can no longer guarantee that rb won't change".
	
	So the question is can you have the best of both worlds, where its fast and won't change? Yes!

	int h (const ReallyBig &rb) {...}; // this way its still fast (no copying) and the parameter cannot change. 
	"Only downside left is if you actually wanted to change rb inside the function, but not outside"
	So here is the advice: 
	Prefer to pass-by-const-ref over pass-by-value for anything lanrger than a pointer. Unless the function needs to make a copy anyway - then maybe pass by value. 
	
	**** 1 More example ****

	int f(int &n) {....};
	int g(const int &n) {...}; 
	
	f(5); // this won't compile
	// because 5 doesn't have an address. Can't initialize an lvalue reference to a literal value.
	// if n changes, can't change the literal 5 because reference is not pointing to a memory
	
	g(5); // perfectly legal
	// because its a constant reference. Since n can never be changed, the compiler allows this.
	// how? - compiler creates a temp location to hold the 5, so ref n has something to point to. 

--------------Dynamic Memory Allocation----------------
	In C, we used to do this: 
	int *p = malloc(_______*sizeof (int));
	....
	free(p);
	"DONT USE THIS IN 246"
	
	Instead, use new/delete, which is better because its:
	-- type aware
	-- less error prone
	
	EXAMPLE TIME!!
	struct Node {
		int data;
		Node *next;
	};
	When this runs, lets look at the stack and the heap:

	Stack:
	------
	np // points to values that are on the heap

	Heap:
	------
	data
	next

	Create a new value on the Heap
	Node *np = new Node;
	....
	delete np;
	
	All local variables are stored on the stack, varaibles are deallocated once they go out of scope. (stack is popped)
	Allocated memory is stored on the heap, it remains there until i say "fuck this shit, im done" (delete is called)
	If you don't delete all allocated memory, you will have a memory leak. Program will eventually fail - incorrect behaviour

	Note: before we asked for space to store only one node
	But we sometimes want to store more things, so we do this:	
		Node *np = new Node[10]; // allocates space for 10 nodes. 
		....
		delete [] (np);

--------------------Return-by-value----------------------
	
	eg: 
	Node getMeANode() {
		Node n;
		return n;
	} // maybe the best option because you might want to take a risk of extra memory use but not have to worry about clearing memory

 	Creating a node and giving it back to the user, requires making a copy. Could be expensive!
	
	Q: How to avoid that copy? 
	A: Return by pointer(ref) instead. 

	Node *getMeANode() {
		Node n;
		return &n;
	} // one of the worst things you can do

	IT RETURNS A POINTER OR A REFERENCE TO A STACK-ALLOCATED DATA THAT IS DEAD ON RETURN.
	// out of scope!!!
	// problem that you will not actually crash a program right away and compiler might not tell you what the problem is

	If you want to return something fast, make sure the thing you are returning is not from the stack
	Node *getMeANode() {
		return new Node; // new allocates space on the HEAP
	} // this works, but you gotta remember that there is something on the heap and you have to delete it at some point	
	
----------------------Operator overloading--------------------

	(this is amazing, changed my life #revolutionary)

	Operator overloading allows us to give meanings to C++ operators for our own types
	eg:
	struct Vec {
		int x, y;
	};

	Vec operator+ (const Vec &v1, const Vec &v2){
		Vec v={v1.x+v2.x, v1.y+v2.y};
		return v;
	}

	Vec operator* (const int k, const Vec &v) {
		return {k*v.x, k*v.y}; // ok because the computer knows that its a Vec based on the return type
	}
	
	Vec operator* (const Vec &v, const int k) {
		return k*v;
	}; 

---------------Overloading << and >> (I/O operators)-------------------

	eg:
	struct Grade {
		int theGrade;
	};


	ostream &operator<< (ostream &out, const Grade &g) { // you have to use references because ostream can not be copied
		out << g.theGrade << '%' // to print a percent sign every time after the grade
		return out; // or "return out << g.theGrade << '%'"
		// key is that we have to return ostream, just like cout does
		// this way we can use cascading effect: cout << x << y << z << endl;
	};

	istream &operator>> (istream &in, Grade &g) { // no const for Grade because you want to change it
		in >> g.theGrade;
		if (g.theGrade < 0) {
			g.thegrade = 0;		
		} 
		if (g.theGrade > 100) { 
			g.theGrade = 100;
		}
		return in; // have to return istream because of the cascading effect
	}
	
	int main () {
		Grade g;
		while (cin >> g) cout << g << endl;
	}

--------------------------The Preprocessor------------------------

	Transforms the program before the compiler sees it. 
	// you know you are dealing with a preprocessor because you will see a line like this: 
	// #_______ - preprocessor directive 
	We already know the #include
		- if you are including old C headers, there is a new naming convention:
		eg: instead of #include <stdio.h> use #include <cstdio>

	#define VAR VALUE // sets a preprocessor variable.
	// acts like search and replace. If preprocessor ever sees a VAR anywhere, it will replace it with VALUE

	#define MAX 10 
	int x[MAX]; // transformed int x[10] a way to create constant variables
	This is very outdated tho, we use const definition instead
	Then why are we covering it? --> It can be used for other things 
	
	#define FLAG // sets the variable FLAG and its value is the empty string
	So once you compile the code, all isntances of FLAG will be gone.

	This is also useful for conditional compilation. Sometimes you want your program to look different in different situations. 
	In order to accomodate for different OSs, you have to vary code a little bit.

	eg:
	#define IOS 1
	#define BBOS 2
	#define OS IOS (or BBOS)
	#if OS == IOS
		short int publickey; // if true, compiler sees this
	#elif OS == BBOS
		long long int publickey; // if false, this code is suppressed and compiler doesn't see it 
	#endif 
	Remember that preprocessor runs before the compiler sees it. 
	
	Special Case:
	#if 0 // this is never true, all inner text is removed before it gets to the compiler
	#endif 
	Good as a heavy duty commenting out

	Can also define symbols via compiler arguments
	eg: 
	int main() {
		cout << X << endl; // won't compile, because x is undefined
	}
	
	But we can define x on the g++ command line
	--> g++ -DX=15 define.cc -o define // this use capitals for all defined variables
	
	#ifdef NAME // true if NAME has been defined
	#ifndef NAME // true if NAME has not been defined

	Useful for debugging
	eg:
	int main() {
		#ifdef DEBUG
			cout << "setting x=1" << endl;
		#endif
			int x=1;
			while (x < 10) {
				++x;
				#ifdef DEBUG
					cout << "x is now" << x << endl;
				#endif
			}
		cout << x << endl;
	}	

	if you compile it normally
	--> g++14 debug.cc -o debug
	if you want to debug 
	--> g++14 -DDEBUG debug.cc -o debug

	
-----------------Separate Compilation-------------------

	You want to split your program into composable modules, with an 
	- interface: contains things such as type definitions, prototypes of functions (your .h file)
	- implementation: the full definition of your functions (your .cc file)

	Recall: 
		when we speak of a declaration, all it does is it asserts existance, whereas definitions give full details and allocate space
		for those things that occupy space. 

	eg: if we take the Matrix functions from before and make them into proper files
	**************vec.h******************
	__________________________________________
	struct Vec {
		int x, y;
	}

	Vec operator+ (const Vec &v1, const Vec &v2);


	*************main.cc************************
	____________________________________________
	#include "vec.h"
	
	int main() {
		Vec v = {1, 2};
		v = v + v;
		.....
	}


	*****************vec.cc*********************
	____________________________________________
	#include "vec.h"
	
	Vec operator+ (const Vec &v1, const Vec &v2) {
		....
		....
		....
	}

	Recall, an entity can be defined many times, but defined at most once.

-----------------Linker (Compiling separately)------------------------
	
	VERY IMPORTANT:
		ls the directory:
			vector.h vector.cc main.cc
		then you run:		
			g++14 vector.cc
		and get a shit error:	// if you get errors in /usr/bin/ld then you are fine, its a linking error
			look at the pre-last line: thats where the error is
		then you run:
			g++14 main.cc
		and get a shit error again // look at the end for error description again
		

	To compile separately, do:
	-> g++14 -c vector.cc
	-> g++14 -c main.cc
	// -c means compile only, do not link, do not build the executable
	So now we have a compiled, but unlinked code: 
		ls the directory:
		main.cc main.o vector.cc vector.o vector.h

	.o file is an object file all compiled, but not liked. 
	To do linking, use 
		g++14 vec.o main.o -o main
	now you can sun ./main

	Notice, we didn't compile .h file. 

	NOTICE!!!!
	NEVER EVER, EVER COMPILE .H FILES EVER!!!!
	!!!!!!!!!code in the .h files is compiled automatically because it is included in other files

	Suppose you wanted to add a global variable 
		Global var: int globalNum;
	You should never include it in the .h file because every time the .h file is included compiler will make a copy of it
	You have to define it in .h, but not initialize it using extern global var;
	Initialize the vatrible in a .cc file global var = 14;

------------------------Including shit in your modules---------------------------

	imagine you have vec.h, vec.cc linalg.h, linalg.cc, main.cc
		!!!!!!this won't compile!!!!!!!!! 
	main.cc, linalg.cc include linalg.h, vec.h
	linalg.h includes vec.h

	-> main.cc, linalg.cc get 2 copies of vec.h

	STRUCT VEC IS DEFINED TWICE 

	Need to prevent files from being included

	Solution: 
	Vec.h:
	#ifdef VEC_H
	#define VEC_H
	.
	. // file content
	.
	#endif

	First time vec.h is included symbol VEC_H is not defined, so file is included. After that VEC_H is defined, so content are suppressed

	Rules: 
	- ALWAYS put include guards in .h files 
	- NEVER include .cc files // you will end up with 2 copies of definitions and functions because you will get one from .cc file and another when .cc is included somewhere else
	- NEVER put using namespace std in header files // if you do that, you are forcing your client not to use std namespace either, which is not fair
		- inside header files always say std::cin, std::string etc.

	Midterm coming up
	-> Better study, do not be behind on aynthing! gotta understand week 1 content

-----------------OOP Classes--------------
	- is different from structs because you can put functions inside of classes
	
	eg:
	struct Student {
		int assns, midterm, final;
		float grade () {
			return assns*0.4 + midterm*0.2 + final*0.4;
		}
	}

	Student s{60, 70, 80} // then you can create a struct 
	cout << s.grade() << endl // and use functions inside classes to return values

	Definitions: 
	- Class -> a struct type that cat contain functions
			-> c++ does have a class keyword. We will cover it later

	- Object -> an instance of a class
			 -> So Student s{60,70,80}. Student is the class and s is the object
			 -> then function grade(), is called a member function or a method. First method that we have written in this course, before this, everything was functions.

	What do assns, midterm, final inside of grade() {.....} mean? What do they refer to, if in struct we didn't initialize anything?
		-> They are fields of the current object // upon which grade was invoked.

	eg: 
	Student billy{60, 70, 80}
	billiy.grade() // This is a method call and inside the grade(), billy's assns, mitderm, final are used.

	This is why methods and functions are different
		Formally: methods takes a hidden extra parameter called "this"
		- this is a pointer to the object on which the medhod was invoked
		eg: billy.grade() // this == &billy

		can write the following to be more formal:
		Struct Student {
			int assns, midterm, final;
			float grade() {
				return this->assns*0.4+this->midterm*0.2+this->final*0.4;
			}
		}

------------------Object Initialization----------------------

	Student billy{60, 70, 80} // ok, but a bit limited

	A better option would be writing a method that does the initialization for us
		- such a method is called a constructor

	Struct Student {
		int assns, midterm, final;
		float grade()  {........}
		
		Student(int assns, int midterm, int final) {
			this->assns=assns;
			this->midterm=midterm;
			this->final=final;
		}
	}

	Now that we have a constructor, we can do this:
		Student billy{60,70,80}; // this is much better

	DIFFERENCE: now we are calling our own constructor
	It works like this: if a constructor has been defined, the three variables are being passed to contructor,
						if no constructor has been defined, these initalize the individual fields of student.

	OR // a different syntax, but does the same thing
	Student billy = Student{60,70,80};

	before we were creating billiy object on the stack. Now to create it on the HEAP:
	Student *pBilly = new Student{60,70,80};

	Advantages of constructors:
	- default parameters
	- overloading
	- sanity checks (validate values) 
		
	eg:
		Struct Student {
			....
			Student (int assns=0, int midterm=0, int final=0) {
				....			
			}
		}

		Now we can do Student Jane{60, 70} // where final is initialized as 0
		Student newKid; // all the marks are 0

	Note:
		- Every class comes with a default constructor (takes no arguments)
	eg: 
		vec v; // something we did a couple days ago. 
			   // this calls a default constructor. What it does is it runs through struct and default-constructs any fields that are objects
			   // in case of vec, it does nothing because there are no objects, all we had are the two ints, which are not considered as objects

	So if it does not do anything, how do you know that it's there?
	-> You can check by taking away the dafault constructor

	The built-in default constructor GOES AWAY if you provide your own costructor
	eg:
	Struct vec {
		int x, y;
		vec(int x, int y) {
			this->x=x;
			this->y=y;
		}
	};

	Now if we run vec v, it won't compile. It compiled before, but it won't anymore, because the default constructor has been overwritten by our own constructor
	// However, before, when we intialized structures the x and y were both uninitialized
	// Remember how we mentioned that default contructor only initializes objects?
	// What happens is that our default constructor, calls the other object's default contructor.. and so on

	What if a struct contains const or refs?
	Struct myStruct {
		const int myConst;
		int &myRef;
	} // this is interesting, because const and ref, must be initialized 
	 
	int z;
	Struct myStruct {
		const int myConst=5;
		int &myRef=z;
	} // we can do this, but its probably not what we want
	// because at the end we will end up with as many myCosnt as objects that we created. We will have way too many duplicates

	But does every instance of myStudent need the same value of myConst?
	eg:
	Struct myStudent {
		const int id; // doesn't change, but you don't need the same one for all students
		...
	}

	So if that is not what we need. How should we do it then?
	// by the time it gets to constructor body, it will be too late, because the fields should have been intialized before that

	What happens when an object is created? 
	1) Space is allocated
	2) Fields are constructed // we want to put our intializations here!!!
	3) Constructor body runs // its too late to intialize variables here because they happen in step 2

	We do that using MEMBER INITIALIZATION LIST (MIL)
	eg:
	Struct Student {
		const int id;
		int assns, midterm, final;
		Struct (int id, int midterm, int final):id{id}, assns{assns}, midterm{midterm}, final{final} { // before we start the construction body, right before the first "{"
			// there are rules tho. Shit before the curly brackets are fileds. Inside the brace brackets are the normal c++ scope rules and id, assns, midterm, final are just parameters
		}
	}

	Notes: 
	- Notice that you can intialize any field this way, not only const and ref
	- The fields are initialized in which they are declared in the class, not in order of MIL. // so that if one field uses a value of another, it still works
	- MIL is sometimes more efficient then setting fields in the body // because no matter what you do, step 2 is going to happen
		eg: you have a String name in your class. if you dont intialize String in your step 2, it will still happen because objects are always intialized in default constructor
			so you will do the work twice, to first initialize string as null and then to give it an actual value
	MORAL!!! embrace the MIL. You should be using it all the time in constructors
	
	What if a field is initialized inline, and in the MIL?

	Struct vec {
		int x=0, y=0;
		vec(int x): x{x} {
			....
		}
	} // MIL takees precedence over regular field initializations
	  // Basically overrides them with its own values 


--------------------Uniform Initialization--------------------------
	
Old ways to initialize:

	int x = 5;
	string s = "hello";
	
	OR

	int x(5);
	string s("hello");
	Student billy(60, 70, 80);

New Preferred method:

	int x{5};
	string s{"hello"};
	Student bily{60,70,80};

Now consider:

	Student billy{60,70,80};
	Student bobby = billy; // How does this intialization happen? 
		- the copy constructor 
		- for constructing one object as copy of another
		- so we get a copy constructor for free


Note: Be very careful with constructors that can take ONE parameter !!!!!!!!!!!
	eg:
	Struct Node {
		int data; 
		Node next;
		.....
		Node (int data): data{data}, next{nullptr} {
			......
		}
	};
	This is dangerous because single argument constructors create implicit conversions // Not good, means c++ is changing types behind your back
	Now we can do:
		Node n{4}; // which is totally cool
	but we can also do this:
		Node n = 4; // which means there is an implicit conversion from int to node
	We have already seen this in string hello = "hello"; // where it creates implicit conversion from char array to string
	Now consider this:
		int f (Node n) {.....};
		f(4); // this works for implicitly converted Node
	Danger is:
	- accidentally passing int to a function that is expecting a Node
	- compiler will not signal an error
	Good practice for these scenarios is to disable implicit conversion. To do that, make constructor explicit
	Struct Node {
		...
		explicit Node(int data): data{data}, next{nullptr} {
			.....
		}
	}
	Node n{4}; // is ok
	Node n = 4; // will signal an error
 

	Note: Every class comes with these constructors
 	- default constructor // default construts all fields that are objects

	- copy constructor // just copies all the fields
		- if you were to decide to build your own copy constructor, it would look like this:
		Struct Student {
			int assns, midterm, final;
			Student (....) {...} // old stuff
			Student (const Student &other): // you know its a copy constructor because it consumes a structure
			assns {other.assns}, midterm {other.midterm}, final {other.final} {.....}
			// this is exactly what the built in constructor does
		}
		Q: When do you need copy constructors that are different than default one?
		Struct Node {
			int data; 
			Node next;
			Node (int data, Node *next): data{data}, next{next} {.....}
			.....
		}
		Node *n = new Node{1, new Node{2, new Node{3, nullptr}}};

		Understanding memory alloc:
		|_Stack_|__Heap___________________|
		n -----> 1|* --> 2|* --> 3|nullptr

		Node m = *n;
		Node *p = new Node{*n}; // using copy constructor
	
		Understanding memory alloc:
		|_Stack_|__Heap___________________|
		m -> 1|* ----> 2|* --> 3|nullptr
		p -----> 1|* --> 2|* --> 3|nullptr
		// the problem here is that you are not copying, but you are simply pointing to already existing nodes 

		A simple copy of fields => only the first node is copied // known as a shallow copy
		// this is not what you want, most likely your intent was to copy the entire list	

		if you want a DEEP copy // copies the whole list
		Then you have to write your own copy constructor

		eg:
		Struct Node {
			int data; 
			Node next;
			Node (int data, Node *next): data{data}, next{next} {.....}
			Node (cosnt Node &other): data{other.data}, next{other.next?new Node {*other.next}:nullptr} { 
			// the trick is that when you call "new Node{*other.next}" recurses, so other values are copied too 
				....
			}
			.....
		}

		The copy constructor is called:
		1) when an object initializes another object
		2) when an object is passed by value
		3) when an object is returned by value (*not always - will discuss later)

		Note:
		- can't override copy contructor
		- should always give it values by reference

	- copy assignment operator 
	- destructor
	- move assignment operator

----------------------Destructors---------------------------

	When an object is destroyed:
		- if stack allocated: goes out of scope
		- if heap allocated: it is deleted
	a mathod called the destructor runs

	Every class has a default destructor // it calls destructors on all the object fields, just like the constructor, but the opposite

	Sequence of events that happens when an object is destroyed:
	1) destructor body runs
	2) field's destructors invoked in reverse declaration order
	3) space is deallocated

	Q: When do we need more out of destructor class?
	Node *np = new Node{1, newNode{2, newNode{3, nullptr}}};
	// if np goes out of scope, only the pointer memory is reclaimed (because its on the stack), the list is leaked

	If we say:
	delete np; // this calls *np's destructor, which doesn't do anything 
			   // 1|*-> 2|*-> 3|nullptr. When we run destructor, it kills only objects. 
	So what happens is we delete *np, first node, but the rest of the list is leaked

	Writing a destructor // "~" tilda is what denotes destructor
	Struct Node {
		......
		~Node(){delete next;} // the way that this works is we delete next and call next's destructor, which deletes the next next etc...
		// so this is recursion again
		// we forogot to check for the case of nullptr, but in c++ it is safe to delete nullptr, so we are good to go
	}
	Now: 
	delete np; // deletes the whole list

-------------------------Copy Assignment--------------------------
	the hardest and trickiest one (will be on the midterm, because everyone fucks it up)

	Student billy{60, 70, 80};
	Student jane = billy; // copy constructor
	
	Now consider if we do this:
	Student mary; // default constructor
	mary = billy; // we are copying billy, but we are not constructing mary
	// "=" is an instance of copy-assignment operator. If you don't provide your own, then it will use the compiler's one by default
	// again, the default one might not be good for all the cases, so sometimes we have to write our own
	// Usually, we need to write our own when we work with pointers. We want to avoid SHALLOW copies
	
	Struct Node {
		.......
		Node &operator=(const Node &other) { // notice that the return type has to be a Node
		
		"""
			Aside: in c++ you can do this:
			a = b = c = 4;
			c = 4; -> b = c; -> a = b;
			that's why we need to return Node, so that cascade effect works
		"""	

			data = other.data;
			delete next; 
			next = other.next?new Node{*other.next}: nullptr; // note we are not building a new object, we are using an object that already exists
			return *this;
		} // So apparently this is all wrong and we just spent 10 minutes on this
	}
	Why dangerous?
	Node n{1, new Node{2, new Node{3, new Node}}};
	n = n; // so now we are deleting old data first, but then we try to access deleted data, 
	// which will probably mess up your whole life and you will have to drop out from CS program and go back home and cry a lot, A LOT, A LOOOT.. 
	This gives undefined behaviour
	NOTE: WHEN WRITING OPERATOR = ALWAYS BE AWARE OF SELF ASSIGNMENT

	So the right version:	
	Struct Node {
		.......
		Node &operator=(const Node &other) {
			if (this == &other) return *this; // now if we encounter self-assignment, we will simply return pointer to this

			data = other.data;
			delete next; 
			next = other.next?new Node{*other.next}: nullptr;
			return *this;
		} 
	}

	Now this is apparently an even better version:
	Struct Node {
		.......
		Node &operator= (const Node &other) {
			if (this == &other) return *this; // now if we encounter self-assignment, we will simply return pointer to this
			// now we happpen to know that new doesn't 100% work, that it might fail. And if new fails, this function will bail out because we wont be able to set a value for next
			// and next will keep pointing to old memory, which corrupts the list
			Node *tmp=next;
			next = other.next?new Node{*other.next}: nullptr; 
			data = other.data;
			delete tmp;
			return *this;
		}
	}	
	This is better because if new fails, next and data has not been cahnged yet, so the node is still in valid state
	Also, the actual check for self assignemnt is not necessary here, because we are making a copy of other no matter what, since im wokrking of a copy, 
	it doesn't matter if we are copying form somewhere else or from myself.

	Now there is another version of operator Equal that does everything that the previous version, but is much simpler to write

	#include <utility>

	struct Node {
		...
		...
		...
		void swap (Node &other) {
			using std::swap;
			swap (data, other.data);
			swap (next, other.next);
		}

		Node &operator= (const Node &other) {
			Node tmp=other; //tmp = copy of other
			swap (tmp); // me = copy of other, tmp = my old fields 
			// now since tmp is stack allocated, it is destroyed when this is returned
			return *this;
		}
	}

-------------Rvalues and Rvalue operators-------------------

	recall: an lvalue is anything with an address
			an lvalue reference is like a constant pointer with automatic dereferencing and is aways initialized to an lvalue

	Node n {1, new Node{2, nullptr}};
	Node m = n; // copy operator
	Node m2;
	m2 = n; // copy assignment operator

	Node plusOne (Node n) {
		for (Node *p = &n; p; p = p->next) {
			++p->data;
		}
		return n;
	}
	what we get from here is a copy of the original list with every value increased by one

	Now we want to do this:
	Node m3 = plusOne(n); // here we run the copy constructor

	But when we run this, we get 2 calls to the Basic Contructor and 4 calls to the Copy constructor
	- 2 calls to the Basic constructor because of the two nodes that we have
	- the question is why the copy contructor gets called twice (2 on way in, 2 on way out)
		- because there are 2 nodes in the list, it calls itself recursively, so for every node it runs twice

	Now, if plusOne(n) is the other, what is it referencing? 
	- here we are pointing to the temporary object that our compiler created for us, because we actually did not initialize anything
	- so other is a reference to this temporary
		- and the copy constructor deep copies the data from this temporary
	
	But the temporary is going to be discarded anyway, as soon as the statement Node m3 = plusOne(n); is done
	- then why are we copying a temp object if it gets thrown away anyways? 
	- wouldn't it be better if we could steal it instead?
	- it very wasteful to copy from the temp
	  
	Example, one of your friends decided to quit CS246, but they have been taking great notes, whereas you didnt take any. 
	Your friend tells you that you can find the notes in the library, and you like, nah bro if you throw them away, just give it to me.

	The key for this to work is you have to be able to tell, whether other is a reference to a temp or a standalone object
	- up untill c++11 this was impossible, but not anymore
	
	Now we rvalue reference Node&& is reference to a temporary object (rvalue) or type Node
	- idea is to copy from lvalue and steal from rvalue
	- for that we have to write a ouw own contructor

	struct Node {
		Node (Node && other): 
			data{other.data}
			next{other.next} // now since the list is going to be destroyed because other is a temporary. We actually have to take values away from other
		{ // this is called a move constructor
			// idea is that instead of copying data, it should steal it
			other.next = nullptr; // else the list is destroyed when other is destroyed
		}
	}

	Now we get 
	- 2 basic constructor calls
	- 2 copy contructors 
	- 1 move constructor
	since move is not recursive, it will excecute in constant time always
	** this is one of the trickier concepts in the course, make sure you understand it **

	Since a need for move can arise when using copy operator, it could also arise whe using copy assignemmt
	Node m;
	m = plusOne(n); // assignment from temp

	we can also write move assignment operator:
	struct Node {
		Node &operator= (Node && other) { // we want to steal other's data, but its assignent operator now, which means that i already have some of my own nodes
			// so you have to destroy my old data. The other is already going to be destoryed, so you simply swap your data with his data
			swap (other);
			return *this;			
		}
	}

	So if you don't define move constructor/assignment operator, the copy versions will be used.
	if the move constructor/assignment is defined, it will replace all calls to the copy constructor/assignment
	when the argument is temporary (rvalue)


---------------------------Copy/Move Elision-----------------------

	Now he will show us something that will blow our minds.. Great, just what i wanted!

	Consider this function:
	Vec makeAVec() {
		return {0, 0}; // invokes a basic constructor
	} 
	Vec v = makeAVec(); // What runs? copy constructor? move constructor?
	// well, he is not sure, so he is going to ask the compiler.. i didnt know they were that close.
	Only the basic constructor runs, which is pretty messed up
	
	Its a specific behaviour of C++

	In some circumstances, the compiler is allowed to skip calling copy of move constructors (but doesn't have to) // wtf is this ai?
	In this example: makeAVec writes its result ({0, 0}) 
	- idea is that it writes its result directly into the space occupied by V in the caller, rahter than copy or move it later
	- though you dont need to know when this stuff happens

	Another Example:
	void doSomething(Vec v) {............}
	Vec v is pass by value // copy or possibly the move constructor
	doSomething(makeAVec()); // the result of makeAVec() is written directly into the parameter.
	// this is allowed even if dropping contructor calls is going to change behaviour of the program (eg. if your constructor prints something)

	Compilers obey something like an ASIF rule // you can do anything you want, as long as its doing something that looks like what you asked.
	Lesson: make sure compiler is not confused by your code // you are not expected to know excetly when move/copy elision is allowed, jsut that its possible. 

	If you need all of the contructors to run: g++ can help you
	- g++14 -fno-elide-constructors // will run all of your contructors
	// but we aware how much slower your code becomes. If your compiler is allowed to skip constructors, its probably skiping thousands on them
	// not just one. So your program might slow down by a lot. (if your code is of decent length)

	In summary: Rule of 5 (BIG 5)
	- if you need a custom version of any one of:
		copy constructor
		copy assignment
		destructor
		move constructor
		move assignemnt
	- then USUALLY you need a custom version of all 5
	// circumstances that requre you to change one of them, usually require others to be changed too.

	Notice: operator= is a member frunction, not a standalone function; whereas for Vec it wasn't
	- You usualyl have the choice to make operator a member or not.
	- when your operator is a member, this is the first argument

	struct Vec {
		int x, y;
		...	
		Vec &operator+ (Vec &other)	{
			return {x+other.x, y+other.y};
		}
		Vec &operator* (const int k) {
			return {x*k, y*k}; // implements v*k			
		}
		// but how do we implement k * v?
		// if the first argument is not Vec, then you write it as a standalone 
	}

	Vec operator+ (const int k, const Vec &v) {
		reutrn v*k;
	}

	Special case of that is when you conside I/O operators

	struct Vec {
		ostream &operator<< (ostream &out) {
		return out << x << " " << y; 
		} // but this will make Vec the first arg;
		// which is somehting you dont want to do for sure	 
	}

	SO DEFINE <<, >> OPERATORS AS STANDALONES

	On the other hand, some operators, by the rules of c++, must be members:
		operator=
		operator[]
		operator->
		operator() // lets you treat objcets as if they were functions
		operatorT // where T is a type. Implicit consversion operator
	


